---
title: DataType
permalink: /javascript/data-type
---
# 데이터 타입

- Primitive Type
	- Number
	- String
	- Boolean
	- null
	- undefined
	- Symbol
	- BigInt
- Object/Reference type
	- Array
	- Function
	- Date
	- RegExp
	- Map, WeakMap
	- Set, WeakSet

## ✨ 데이터 할당 원리

> JavaScript에서 변수에 값을 직접 대입하지 않고 데이터 영역에 값을 저장하고 그 **주소를 변수에 할당**하는 이유는 무엇일까요?

### 💡 이유
- **데이터 변환의 유연성**을 확보하기 위함입니다.
- **메모리 효율성**을 극대화하기 위한 설계입니다.

### 📚 예시

### 1. 문자열 변환

```js
var a = 'abc';
a = a + 'def';
```

- 문자열 `'abc'`에 `'def'`를 추가해야 하는 경우, 기존 메모리 공간을 변경하는 대신 **새로운 문자열** `'abcdef'`를 별도의 공간에 저장하고, 해당 **주소를 변수에 연결**합니다.
#### 그림

![](/assets/image01.png)

### 2. 숫자 할당 효율성
- 500개의 변수를 생성하여 각 변수에 숫자 `5`를 할당하는 상황을 가정해 봅시다:
    - 개별로 숫자 `5`를 저장하면 500개의 공간이 필요하며, 숫자형은 8바이트를 사용하므로 총 4000바이트가 필요합니다.
    - 그러나 숫자 `5` 를 별도의 공간에 한 번만 저장하고 각 변수에 그 주소(예: 2바이트 크기)를 저장한다면, 1008바이트(500 × 2 + 8)만 사용하면 됩니다.

### 🔗 결론
- **변수 영역과 데이터 영역을 분리**하면, **중복된 데이터에 대한 메모리 사용이 효율적**입니다. 이를 통해 JavaScript는 메모리를 보다 효과적으로 관리할 수 있습니다.

# 🔄 변수와 불변성

## 🔑 변수와 상수

- *변수와 상수를 구분 짓는 변경 가능성 대상* : 변수 영역의 메모리
- *불변성 여부를 구분할 때의 변경 가능성의 대상* : 데이터 영역의 메모리

## 🛑 불변성

- **데이터 영역의 메모리**는 불변성을 가집니다.
- 문자열, 숫자 값도 다른 값으로 변경할 수 없다.
- 기존 값을 변경할 수 없으며, 새로운 값을 만들어 대체합니다.
- 이것이 **불변값의 성질**이며, **기본형(Primitive) 타입은 불변성을 가집니다**.

## 🔄 가변성

- **기본형 데이터**는 불변값입니다.
- **참조형 데이터**:
    - **기본 성질**은 가변값입니다.
    - **설정에 따라 변경 불가능**하게 만들 수도 있으며, **불변값으로 활용**할 수도 있습니다.

> **참조형 데이터**의 경우, 객체의 변수(프로퍼티) 영역이 별도로 존재하며, 객체가 할애한 **변수 영역**은 데이터 영역과는 다릅니다. **데이터 영역에 저장된 값은 모두 불변값**입니다. 참조형 데이터가 **가변값**인 이유는 변수에 다른 값을 **얼마든지 대입할 수 있기 때문**입니다.

```js
var obj1 = {
  a: 1,
  b: 'bbb'
};
obj1.a = 2;
```

- 위 코드에서 `obj1`이 바라보는 **주소는 변하지 않으며**, **새로운 객체가 만들어지는 것이 아니라** 기존 객체의 내부 값만 변경됩니다.

### 🌳 중첩 객체
#### 🗂️ 중첩 객체 할당 원리

```js
var obj = {
  x: 3,
  arr: [3, 4, 5]
};
```

> 중첩 객체에서 `obj.arr[1]`을 검색할 때의 과정을 살펴보자.
#### 그림

![](/assets/image02.png)

1. `obj` 검색
    - obj라는 식별자를 가진 주소를 찾습니다 (@1002)
    - 값이 주소이므로 그 주소로 이동합니다 (@5001)
2. `obj.arr`  검색
    - arr이라는 식별자를 가진 주소를 찾습니다 (@7104)
    - 값이 주소 이므로 그 주소로 이동합니다 (@5003)
3. `obj.arr[1]`  검색
    - 인덱스 `1`에 해당하는 주소를 찾습니다 (@8105)
    - 값이 숫자형 데이터이므로, 해당 값을 반환합니다 (4)


# 🔄 변수 복사 비교

```js
var a = 10;
var b = a;
console.log(a); // 10
console.log(b); // 10
b = 20;
console.log(a); // 10
console.log(b); // 20

var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;
console.log(obj1); // { c: 10, d: 'ddd' }
console.log(obj2); // { c: 10, d: 'ddd' }
obj2.c = 20;
console.log(obj1); // { c: 20, d: 'ddd' }
console.log(obj2); // { c: 20, d: 'ddd' }
```

> 같은 객체를 바라보고 있어서 복사한 `obj2` 의 프로퍼티 `c` 를 변경 했음에도 `obj1` 의 값도 마치 바뀐것처럼 보인다.

- 기본형 데이터와 참조형 데이터 모두 같은 주소를 바라보며 복사된다.
	- 기본형 데이터는 복사한 변수의 값을 변경 하면 주소가 달라지며, 원본 변수에는 영향을 미치지 않는다.
	- 참조형 데이터의 경우, 복사한 변수의 프로퍼티 값을 변경하면 원본 객체에도 영향을 미치며, 이는 두 변수가 여전히 같은 객체를 바라보고 있기 때문이다.
- 이것이 기본형과 참조형 데이터의 큰 차이점이다.
	- JS에서 모든 데이터 타입은 참조형 데이터로 처리되지만, 기본형 주소값을 한번만 참조하고, 참조형은 한 단계 더 거친다는 차이가 있다.
	- 기본형 데이터도 결국 주소값을 참조한다.

# 🌐 객체 자체를 변경할 때

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'ddd' };
var obj2 = obj1;

b = 15;
obj2 = { c: 20, d: 'ddd' };
```

- `b`와 마찬가지로 `obj2`에도 새로운 객체를 할당하면서 값을 직접 변경합니다.
- 참조형 데이터의 '가변성'은 *객체 자체를 변경할 때가 아니라* 그 내부 프로퍼티를 변경할 때만 성립한다.
	- *참조형 데이터 자체를 바꾸는 것은 불변성을 따른다* 

# 🔒 불변 객체

- 참조형 데이터의 '가변성' 은 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립합니다.
- 데이터 자체를 변경하려고 하면, 기존 데이터는 변하지 않으며 새로운 데이터를 생성합니다. 이는 기본형 데이터와 동일한 특성입니다.
- immutable.js: 내부 프로퍼티를 변경할 때마다 새로운 객체를 만들어 재할당하거나, 자동으로 새로운 객체를 만드는 도구입니다.

### 🤔 불변 객체가 필요한 상황
- 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 **불변 객체**가 필요합니다. 이는 데이터의 안전성을 보장하고, 의도치 않은 부작용을 방지하는 데 도움이 됩니다.

# 🔀 얕은 복사와 깊은 복사

## 📝 얕은 복사 (Shallow Copy)

- **바로 아래 단계의 값만 복사하는 방법**입니다.
- 중첩된 객체에서 **참조형 데이터가 저장된 프로퍼티를 복사**할 때, 그 **주소만 복사**한다는 의미입니다.
	- 해당 프로퍼티에 대해 **원본과 사본이 모두 동일한 참조형 데이터의 주소를 가리키게** 됩니다.
	- 따라서 **사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀝니다**.

```js
var copyObject = function(target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};

var user = {
  name: 'Jaenam',
  urls: {
    portfolio: 'https://github.com',
    blog: 'https://github.com',
    facebook: 'http://facebook.com'
  }
};

var user2 = copyObject(user);

user2.name = 'Jung';
console.log(user.name === user2.name); // false

user.urls.portfolio = 'https://portfolio.com';
console.log(user.urls.portfolio === user2.urls.portfolio); // true

user2.urls.blog = '';
console.log(user.urls.blog === user2.urls.blog); // true
```

> 참조형 데이터인 `urls` 가 얕은 복사 되었기 때문에, 원본과 사본이 동일한 참조형 데이터 주소를 가리킵니다.
> 이를 해결하기 위해서는 `urls` 도 불변 객체로 만들어야 한다.

## 📝 깊은 복사 (Deep Copy)

- **내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법**입니다.
- 어떤 객체를 복사할 때, 객체의 프로퍼티 중 **기본형 데이터**는 그대로 복사하고, **참조형 데이터**는 다시 그 **내부의 프로퍼티들을 복사**해야 합니다.

```js
var copyObjectDeep = function(target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }
  return result;
};

var obj = {
  a: 1,
  b: {
    c: null,
    d: [1, 2]
  }
};
var obj2 = copyObjectDeep(obj);
obj2.a = 3;
obj2.b.c = 4;
obj.b.d[1] = 3;
console.log(obj); // { a: 1, b: { c: null, d: [ 1, 3 ] } }
console.log(obj2); // { a: 3, b: { c: 4, d: { '0': 1, '1': 2 } } }
```

## 📝 얕은 복사 vs 깊은 복사

- **얕은 복사**는 **객체의 최상위 단계**만 복사하므로, 내부에 있는 참조형 데이터는 **주소만 복사**됩니다.
- **깊은 복사**는 **객체의 모든 단계**를 재귀적으로 복사하여, **완전한 복사본**을 만듭니다. 이를 통해 **원본 객체와 독립적으로 동작**할 수 있습니다.

# undefined와 null

- undefined: 변수가 초기화되지 않았을 때 자동 할당되는 값
- null: 사용자가 명시적으로 없음을 나타내기 위해 할당한 값

## 🔍 JS 엔진이 자동으로 undefined를 부여하는 경우

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. `return` 문이 없거나 호출되지 않는 함수의 실행 결과

### 🚩 undefined 구분

- 사용자가 명시적으로 부여한 경우
    - `undefined`는 그 자체로 값입니다.
    - 순회의 대상이 됩니다.
    - 실존하는 데이터로 간주됩니다.
- 비어있는 요소에 접근하려 할 때 반환되는 경우
    - 해당 프로퍼티나 배열의 키값 자체가 존재하지 않음을 의미합니다.
    - JS 엔진이 반환하는 `undefined`는 문자 그대로 값이 없음을 나타냅니다.

### 🟢 null 사용

- **비어있는 값을 명시적으로 나타내고 싶을 때** `null`을 사용합니다.
- `typeof null`은 `'object'`로 출력되며, 이는 JS 자체의 버그입니다.
