
**트랜잭션**

**기본 개념**
1. **트랜잭션이란 무엇인가요?**
	1. 트랜잭션은 데이터베이스에서 하나의 작업 단위로 실행되는 일련의 연산 집합입니다. 모든 연산이 완전히 수행되거나(Commit), 전혀 수행되지 않은 상태(Rollback)로 되돌릴 수 있어야 합니다. 예를 들어, 은행 이체에서 송금과 수신이 함께 완료되지 않으면 데이터 불일치가 발생할 수 있으므로 트랜잭션으로 묶습니다.
2. **트랜잭션의 ACID 특성은 무엇인가요?**
	- **Atomicity**: 모두 성공하거나, 모두 실패해야 합니다.
	- **Consistency**: 트랜잭션 전과 후에 데이터는 일관성을 유지해야 합니다.
	- **Isolation**: 동시에 실행되는 트랜잭션은 서로 간섭해서는 안 됩니다.
	- **Durability**: 커밋된 데이터는 시스템 장애에도 유지되어야 합니다.
3. **트랜잭션의 예시를 들어 설명해주세요.**

**트랜잭션 격리 수준 (Isolation Levels)**
4. **트랜잭션 격리 수준(Isolation level)에는 어떤 종류가 있나요?**
	- READ UNCOMMITTED : 커밋되지 않은 데이터를 읽을 수 있어 Dirty Read 발생 가능
	- READ COMMITTED: 커밋된 데이터만 읽음 → Non-Repeatable Read 발생 가능
	- REPEATABLE READ: 같은 트랜잭션 내에서는 같은 데이터를 읽음 → Phantom Read 가능
	- SERIALIZABLE: 트랜잭션을 직렬화하여 완전한 고립 → 가장 안전하지만 성능 저하
5. **각 격리 수준에서 발생할 수 있는 문제점은 무엇인가요?**
	- **Dirty Read**: 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽음
	- **Non-Repeatable Read**: 동일 쿼리를 두 번 실행했을 때 결과가 달라짐
	- **Phantom Read**: 조건은 같지만 범위에 포함되는 레코드 수가 달라짐 (INSERT/DELETE)
6. **MySQL의 기본 격리 수준은 무엇인가요?**
	- MySQL의 InnoDB 스토리지 엔진은 기본적으로 **REPEATABLE READ**를 사용합니다. 이는 Non-Repeatable Read는 방지하지만, Phantom Read는 방지하지 못합니다. MVCC를 통해 동시성을 확보합니다.
7. **READ COMMITTED와 REPEATABLE READ의 차이점은 무엇인가요?**
	- **READ COMMITTED**는 트랜잭션 내에서 **다른 트랜잭션이 커밋한 데이터를 즉시 읽을 수** 있도록 허용합니다. 반면, **REPEATABLE READ**는 트랜잭션이 시작된 시점의 데이터를 기준으로 **반복 조회 시 항상 동일한 결과**가 보장되도록 합니다.
		- **READ COMMITTED**: 커밋된 데이터만 읽을 수 있지만, 같은 SELECT 문을 여러 번 실행할 때 결과가 달라질 수 있습니다 (Non-Repeatable Read 발생)
		- **REPEATABLE READ**: SELECT 결과가 항상 동일하지만, 새로운 행 삽입(INSERT)에 의한 **Phantom Read**는 발생할 수 있습니다.
✅ **동시성 제어 및 Lock**
8. **낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)의 차이는 무엇인가요?**
	- **비관적 락(Pessimistic)** 은 트랜잭션 시작 시점에 락을 걸어 다른 트랜잭션의 접근을 막습니다. 충돌을 피하고 싶은 환경에 유리합니다.
	- **낙관적 락(Optimistic)** 은 변경 전 버전 정보를 확인하고 충돌이 있을 경우에만 롤백합니다. 대부분의 경우 충돌이 없다고 가정하고 성능이 좋습니다.
10. **비관적 락은 어떤 상황에서 사용하나요?**
11. **트랜잭션에서 Lock이란 무엇인가요?** 
	- 트랜잭션에서 **Lock(잠금)** 은 **동시성 제어**를 위한 핵심 메커니즘으로, 여러 트랜잭션이 동시에 같은 데이터에 접근할 때 데이터의 정합성을 보장하기 위해 사용됩니다. 락을 걸면 다른 트랜잭션이 해당 자원에 접근하거나 변경하지 못하도록 막아줍니다
12. Lock에는 어떤 종류가 있나요?
	- 공유 락 (Shared Lock, S-Lock)
		- **읽기 작업**에서 사용되며, 다른 트랜잭션도 동시에 읽을 수 있습니다.
		- 하지만 **쓰기 작업은 불가능**합니다.
	- 배타 락 (Exclusive Lock, X-Lock)
		- **읽기 및 쓰기 모두를 독점**합니다.
		- 다른 트랜잭션은 해당 데이터를 읽거나 쓸 수 없습니다.
	- 테이블 락 (Table Lock)
		- 테이블 전체에 락을 걸어, 병렬 처리가 제한됩니다.
		- 단순한 연산에서는 빠르지만, **병목이 발생하기 쉬움** 
		- 예: MyISAM은 기본적으로 Table Lock 사용
	- 행 락 (Row Lock)
		- 특정 **행(Row) 단위로 잠금**을 걸어, 더 세밀한 동시성 제어가 가능합니다.
		- 대부분의 트랜잭션 환경에서는 **Row Lock이 더 유리**합니다.
		- InnoDB는 기본적으로 Row Lock 기반입니다.
✅ **실무 및 성능 관점**
13. **트랜잭션을 사용하는 이유는 무엇인가요?**
14. **트랜잭션을 남용하면 안 되는 이유는 무엇인가요?** 
15. **트랜잭션과 성능의 관계는 어떤가요?** 
	- 트랜잭션은 데이터 무결성을 보장하지만, **락 경합, 커넥션 유지 비용** 등으로 인해 성능 저하를 초래할 수 있습니다. 특히 장기 트랜잭션은 자원을 오래 점유하게 되어 병목의 원인이 됩니다. 따라서 필요한 최소 범위에서 트랜잭션을 사용하는 것이 좋습니다.
16. **트랜잭션 중 오류가 발생하면 어떻게 처리하나요?**
	- 트랜잭션 내에서 예외가 발생하면 `ROLLBACK`을 호출해 모든 작업을 원자적으로 취소해야 합니다.
17. **DB 커넥션 풀과 트랜잭션의 관계는 어떻게 되나요?** 
18. **트랜잭션이 제대로 종료되지 않을 경우 어떤 문제가 발생하나요?**
✅ **응용/실전 설계**
19. **트랜잭션이 필요한 API와 필요 없는 API를 구분해보세요.**
20. **결제 시스템에서 트랜잭션을 어떻게 구성할 수 있을까요?**
21. **복잡한 작업(예: 주문 생성 → 재고 차감 → 결제 요청)을 트랜잭션으로 어떻게 묶나요?**
✅ **심화 / 확장 개념**
22. **분산 트랜잭션이란 무엇인가요?**
	- 분산 트랜잭션은 둘 이상의 서로 다른 데이터 소스 또는 시스템 간에 걸친 트랜잭션입니다. 전통적인 방식은 **2단계 커밋(2PC)** 이 있으며, 최근에는 **SAGA 패턴**을 사용해 각 단계마다 보상 트랜잭션을 정의하여 eventual consistency를 보장하는 방식도 사용됩니다. 마이크로서비스 환경에서 자주 활용됩니다.
23. **2단계 커밋(2PC)은 무엇인가요?**
24. **SAGA 패턴이란 무엇이며, 어떤 상황에서 사용하나요?**
25. **CAP 이론과 트랜잭션의 관계는 어떤가요?**
26. **MVCC란무엇인가요?트랜잭션과 어떤 관계가 있나요?**
27. MVCC vs 락 기반 동시성 제어
28. Phantom Read 현상과 Gap Lock 동작 방식
