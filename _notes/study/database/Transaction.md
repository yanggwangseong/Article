
**트랜잭션**

**기본 개념**
1. **트랜잭션이란 무엇인가요?**
	1. 트랜잭션은 데이터베이스에서 하나의 작업 단위로 실행되는 일련의 연산 집합입니다. 모든 연산이 완전히 수행되거나(Commit), 전혀 수행되지 않은 상태(Rollback)로 되돌릴 수 있어야 합니다. 예를 들어, 은행 이체에서 송금과 수신이 함께 완료되지 않으면 데이터 불일치가 발생할 수 있으므로 트랜잭션으로 묶습니다.
2. **트랜잭션의 ACID 특성은 무엇인가요?**
	- **Atomicity**: 모두 성공하거나, 모두 실패해야 합니다.
	- **Consistency**: 트랜잭션 전과 후에 데이터는 일관성을 유지해야 합니다.
	- **Isolation**: 동시에 실행되는 트랜잭션은 서로 간섭해서는 안 됩니다.
	- **Durability**: 커밋된 데이터는 시스템 장애에도 유지되어야 합니다.
3. **트랜잭션의 예시를 들어 설명해주세요.**

**트랜잭션 격리 수준 (Isolation Levels)**
4. **트랜잭션 격리 수준(Isolation level)에는 어떤 종류가 있나요?**
	- READ UNCOMMITTED : 커밋되지 않은 데이터를 읽을 수 있어 Dirty Read 발생 가능
	- READ COMMITTED: 커밋된 데이터만 읽음 → Non-Repeatable Read 발생 가능
	- REPEATABLE READ: 같은 트랜잭션 내에서는 같은 데이터를 읽음 → Phantom Read 가능
	- SERIALIZABLE: 트랜잭션을 직렬화하여 완전한 고립 → 가장 안전하지만 성능 저하
5. **각 격리 수준에서 발생할 수 있는 문제점은 무엇인가요?**
	- **Dirty Read**: 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽음
	- **Non-Repeatable Read**: 동일 쿼리를 두 번 실행했을 때 결과가 달라짐
	- **Phantom Read**: 조건은 같지만 범위에 포함되는 레코드 수가 달라짐 (INSERT/DELETE)
6. **MySQL의 기본 격리 수준은 무엇인가요?**
	- MySQL의 InnoDB 스토리지 엔진은 기본적으로 **REPEATABLE READ**를 사용합니다. 이는 Non-Repeatable Read는 방지하지만, Phantom Read는 방지하지 못합니다. MVCC를 통해 동시성을 확보합니다.
7. **READ COMMITTED와 REPEATABLE READ의 차이점은 무엇인가요?**
	- **READ COMMITTED**는 트랜잭션 내에서 **다른 트랜잭션이 커밋한 데이터를 즉시 읽을 수** 있도록 허용합니다. 반면, **REPEATABLE READ**는 트랜잭션이 시작된 시점의 데이터를 기준으로 **반복 조회 시 항상 동일한 결과**가 보장되도록 합니다.
		- **READ COMMITTED**: 커밋된 데이터만 읽을 수 있지만, 같은 SELECT 문을 여러 번 실행할 때 결과가 달라질 수 있습니다 (Non-Repeatable Read 발생)
		- **REPEATABLE READ**: SELECT 결과가 항상 동일하지만, 새로운 행 삽입(INSERT)에 의한 **Phantom Read**는 발생할 수 있습니다.
✅ **동시성 제어 및 Lock**
8. **낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)의 차이는 무엇인가요?**
	- **비관적 락(Pessimistic)** 은 트랜잭션 시작 시점에 락을 걸어 다른 트랜잭션의 접근을 막습니다. 충돌을 피하고 싶은 환경에 유리합니다.
	- **낙관적 락(Optimistic)** 은 변경 전 버전 정보를 확인하고 충돌이 있을 경우에만 롤백합니다. 대부분의 경우 충돌이 없다고 가정하고 성능이 좋습니다.
9. **비관적 락은 어떤 상황에서 사용하나요?**
	- 비관적 락(Pessimistic Lock)은 **다른 트랜잭션과의 충돌 가능성이 높을 때**, 즉 **동시에 같은 데이터를 수정할 위험이 큰 환경**에서 사용합니다.
	- 데이터 무결성을 최우선으로 보장해야 하며, **락을 선점하여 충돌 자체를 방지**하는 것이 목적입니다.
10. **트랜잭션에서 Lock이란 무엇인가요?** 
	- 트랜잭션에서 **Lock(잠금)** 은 **동시성 제어**를 위한 핵심 메커니즘으로, 여러 트랜잭션이 동시에 같은 데이터에 접근할 때 데이터의 정합성을 보장하기 위해 사용됩니다. 락을 걸면 다른 트랜잭션이 해당 자원에 접근하거나 변경하지 못하도록 막아줍니다.
11. Lock에는 어떤 종류가 있나요?
	- 공유 락 (Shared Lock, S-Lock)
		- **읽기 작업**에서 사용되며, 다른 트랜잭션도 동시에 읽을 수 있습니다.
		- 하지만 **쓰기 작업은 불가능**합니다.
	- 배타 락 (Exclusive Lock, X-Lock)
		- **읽기 및 쓰기 모두를 독점**합니다.
		- 다른 트랜잭션은 해당 데이터를 읽거나 쓸 수 없습니다.
	- 테이블 락 (Table Lock)
		- 테이블 전체에 락을 걸어, 병렬 처리가 제한됩니다.
		- 단순한 연산에서는 빠르지만, **병목이 발생하기 쉬움** 
		- 예: MyISAM은 기본적으로 Table Lock 사용
	- 행 락 (Row Lock)
		- 특정 **행(Row) 단위로 잠금**을 걸어, 더 세밀한 동시성 제어가 가능합니다.
		- 대부분의 트랜잭션 환경에서는 **Row Lock이 더 유리**합니다.
		- InnoDB는 기본적으로 Row Lock 기반입니다.
✅ **실무 및 성능 관점**
12. **트랜잭션을 사용하는 이유는 무엇인가요?**
	- 트랜잭션은 데이터의 **원자성, 일관성, 동시성 제어, 복구 가능성**을 보장하여 실무에서 안정적인 데이터 처리를 가능하게 합니다.
	- 트랜잭션은 **데이터 무결성과 일관성을 보장하기 위해 반드시 필요**합니다. 여러 개의 작업이 하나의 논리적 단위로 실행될 때, 그 중 하나라도 실패하면 전체 작업을 취소해야 하는 상황이 많습니다.
	- 예를 들어, **주문 생성 → 재고 차감 → 결제 처리**가 하나의 흐름이라면, 이 작업 중 하나라도 실패할 경우 전체 작업을 롤백해야 데이터 정합성을 유지할 수 있습니다.
	- 또한, 다중 사용자 환경에서 **동시성 문제(예: Dirty Read, Lost Update)** 를 방지하기 위해서도 트랜잭션은 필수적입니다.
13. **트랜잭션을 남용하면 안 되는 이유는 무엇인가요?** 
	- 트랜잭션을 과도하게 사용하면 락 경합, 커넥션 점유, Deadlock과 같은 성능 병목이 발생할 수 있으므로, **최소 범위에서 필요한 곳에만 신중하게 적용**해야 합니다.
	- 남용을 피해야 하는 케이스 4개
		- **락 경합 증가**
			- 트랜잭션이 길어질수록 더 많은 데이터에 락이 걸려 **동시성 저하** 발생
		- **커넥션 점유** 
			- 커넥션 풀 환경에서 트랜잭션이 오래 지속되면 **다른 요청이 대기 상태에 빠짐** 
		- **Undo/Redo 로그 증가** 
			- 불필요한 트랜잭션 유지로 **스토리지 I/O 부하 증가** 
		- **Deadlock 위험 증가** 
			- 여러 리소스를 동시에 트랜잭션으로 점유하면 교착상태 가능성이 높아집니다.
14. **트랜잭션과 성능의 관계는 어떤가요?** 
	- 트랜잭션은 데이터 무결성을 보장하지만, **락 경합, 커넥션 유지 비용** 등으로 인해 성능 저하를 초래할 수 있습니다. 특히 장기 트랜잭션은 자원을 오래 점유하게 되어 병목의 원인이 됩니다. 따라서 필요한 최소 범위에서 트랜잭션을 사용하는 것이 좋습니다.
15. **트랜잭션 중 오류가 발생하면 어떻게 처리하나요?**
	- 트랜잭션 내에서 예외가 발생하면 `ROLLBACK`을 호출해 모든 작업을 원자적으로 취소해야 합니다.
16. **DB 커넥션 풀과 트랜잭션의 관계는 어떻게 되나요?** 
	- 💬 Answer) 트랜잭션은 커넥션 단위로 동작하므로, 트랜잭션이 길어질수록 커넥션 풀이 점점 고갈되어 **대기 요청이 늘거나 애플리케이션 전체의 응답 속도 저하**로 이어질 수 있습니다. 따라서 트랜잭션은 **최소한의 범위 내에서 빠르게 종료하는 것이 중요**합니다.
	- **DB 커넥션 풀**은 애플리케이션이 **필요할 때마다 DB 연결을 생성/해제하지 않고, 미리 연결을 만들어 재사용**하도록 해주는 성능 최적화 기법입니다.
	- **트랜잭션은 커넥션 단위로 관리되기 때문에**, 트랜잭션을 사용하는 동안은 커넥션 풀의 커넥션 하나가 **점유 상태**가 됩니다.
	- 핵심 관계 이해)
		- 트랜잭션이 시작되면 → 커넥션 풀에서 커넥션 하나를 할당
		- 트랜잭션이 **commit 또는 rollback** 되어야 → 커넥션이 반환됨
		- 커넥션을 반환하지 않으면 → **풀 고갈(pooled connection exhaustion)** 발생
17. **트랜잭션이 제대로 종료되지 않을 경우 어떤 문제가 발생하나요?**
	- 💬 Answer) 트랜잭션이 종료되지 않으면 **락 미해제, 커넥션 점유, 로그 증가** 등으로 인해 시스템 전체에 병목과 장애를 유발할 수 있습니다. 특히 트랜잭션이 열린 상태로 남으면 커넥션 풀이 고갈되기 쉬워, 실무에서는 항상 `try-catch-finally` 구문 등을 통해 **명시적으로 rollback 또는 commit을 보장**하는 것이 중요합니다.
	- 트랜잭션이 `COMMIT` 또는 `ROLLBACK` 없이 **열린 상태(open transaction)**로 남아있으면 다음과 같은 문제가 발생합니다
	- **1) 락이 해제되지 않음** 
		- 해당 트랜잭션이 걸어놓은 락이 유지되어 → **다른 트랜잭션이 대기**하게 됨 (→ 락 경합, 병목)
	- **2) 커넥션이 반환되지 않음** 
		- 커넥션 풀을 점유하여 → **풀 고갈 → 요청 대기 또는 오류 발생** 
	- **3) Undo/Redo 로그가 계속 쌓임** 
		- 리소스를 소모하고, 디스크 공간 증가 → **성능 저하** 
	- **4) Deadlock 유발 가능성** 
		- 여러 트랜잭션이 서로 락을 기다리게 되면 **교착 상태 발생** 
	- **5) 비즈니스 로직 오류** 
		- 트랜잭션이 제대로 종료되지 않으면, 데이터가 **중간 상태(inconsistent state)** 로 남아 문제 유발
✅ **응용/실전 설계**
18. **트랜잭션이 필요한 API와 필요 없는 API를 구분해보세요.**
19. **결제 시스템에서 트랜잭션을 어떻게 구성할 수 있을까요?**
20. **복잡한 작업(예: 주문 생성 → 재고 차감 → 결제 요청)을 트랜잭션으로 어떻게 묶나요?**
✅ **심화 / 확장 개념**
21. **분산 트랜잭션이란 무엇인가요?**
	- 분산 트랜잭션은 둘 이상의 서로 다른 데이터 소스 또는 시스템 간에 걸친 트랜잭션입니다. 전통적인 방식은 **2단계 커밋(2PC)** 이 있으며, 최근에는 **SAGA 패턴**을 사용해 각 단계마다 보상 트랜잭션을 정의하여 eventual consistency를 보장하는 방식도 사용됩니다. 마이크로서비스 환경에서 자주 활용됩니다.
22. **2단계 커밋(2PC)은 무엇인가요?**
	- 💬 Answer) 2PC는 **분산 환경에서도 원자성(Atomicity)을 보장**하는 방식이지만, 각 노드가 응답을 기다리느라 **지연(latency)** 이 발생하고, **Coordinator 장애 시 blocking** 문제가 있다는 단점이 있습니다.
	- **2PC(Two-Phase Commit)** 은 분산 시스템에서 **여러 데이터 소스 간의 트랜잭션 일관성을 보장하기 위한 프로토콜**입니다.
	- 트랜잭션을 **Coordinator와 Participant**로 나누고, 두 단계로 커밋을 수행합니다.
	- 동작 단계
		- **Prepare Phase**: Coordinator가 모든 참여 노드에게 “준비됐냐?”를 물어봄
		- **Commit Phase**: 모두 OK일 경우 → 실제 commit, 누가 no면 → 전부 rollback
23. **SAGA 패턴이란 무엇이며, 어떤 상황에서 사용하나요?** 
	- 💬 Answer) SAGA는 **2PC의 블로킹 단점과 복잡성**을 피하면서 **eventual consistency**를 보장할 수 있는 **실무 친화적인 분산 트랜잭션 대안**입니다.
	- SAGA는 **분산 트랜잭션을 구현하는 패턴**으로, 2PC의 단점을 극복하기 위해 등장했습니다. 각 단계는 **로컬 트랜잭션 + 보상 트랜잭션(compensation transaction)** 으로 구성되며, 전체 작업의 성공/실패를 유연하게 처리합니다.
	- 사용시점)
		- 마이크로서비스 아키텍처에서 각 서비스가 자체 DB를 가질 때
		- 장기 실행 작업에서 blocking 없이 eventual consistency가 필요한 경우
24. **CAP 이론과 트랜잭션의 관계는 어떤가요?**
	- 💬 Answer) CAP 이론에 따라 분산 트랜잭션은 **완벽한 ACID보다는 성능과 가용성을 고려한 타협**이 필요합니다. 그래서 실무에서는 2PC 대신 **SAGA, eventual consistency**가 많이 사용됩니다.
	- CAP 이론은 분산 시스템에서 **Consistency(일관성), Availability(가용성), Partition Tolerance(네트워크 분할 허용성)** 중 **세 가지를 동시에 만족시킬 수 없다는 이론**입니다.
		- 트랜잭션과의 관계)
			- 트랜잭션은 **C(일관성)** 을 중요시합니다.
			- 하지만 실무에서 Partition이 필연적이므로, **가용성(A) vs 일관성(C)** 사이의 선택이 필요 합니다.
		- 예시)
			- SAGA는 **C보다 A를 중시**하여 eventual consistency를 선택
			- 2PC는 **C를 중시**하여 strict consistency 보장
25. **MVCC란무엇인가요?트랜잭션과 어떤 관계가 있나요?** 
	- 💬 Answer) MVCC는 트랜잭션 간 충돌을 줄이면서도 **동시성과 성능을 확보**할 수 있는 핵심 동시성 제어 방식으로, 특히 **InnoDB, PostgreSQL** 등에서 널리 사용됩니다.
	- **MVCC(Multi-Version Concurrency Control)** 는 동시에 여러 트랜잭션이 동작할 때도 **락 없이 읽기 일관성을 제공하는 기법** 입니다.
	- 각 트랜잭션은 자신만의 **스냅샷 버전**을 가지고 읽고, 최신 버전이 아니라도 읽기 동작이 가능하도록 합니다.
	- 주요 특징)
		- 읽기 작업에서 락을 사용하지 않음 → 성능 향상
		- 변경 시 새로운 버전 생성 → 이전 버전은 undo log에 저장됨
26. MVCC vs 락 기반 동시성 제어
- 💬 Answer) MVCC는 성능과 동시성을 중시하는 환경에 적합하며, 락 기반 제어는 **충돌이 치명적인 환경**에 적합합니다. 상황에 따라 적절한 제어 방식이 필요합니다.

|항목|MVCC|락 기반 제어|
|---|---|---|
|읽기 일관성|스냅샷 기반 (락 없이 가능)|읽기에도 락 필요 (비관적 락)|
|쓰기|새로운 버전 생성|X-lock 필요|
|동시성|높음|낮음 (경합 가능성 ↑)|
|지연시간|낮음|트랜잭션 충돌 시 지연 발생|
|사용 예|PostgreSQL, InnoDB|전통적인 RDBMS, 금융 등 충돌 민감 환경|

27. Phantom Read 현상과 Gap Lock 동작 방식
- 💬 Answer) Phantom Read는 일반적인 락으로 방지되지 않지만, InnoDB는 Gap Lock을 통해 **행 사이의 공간까지 잠그는 방식**으로 이를 방지합니다. 이는 Phantom Read를 막기 위한 핵심 기술입니다.
- **Phantom Read**는 **같은 조건의 SELECT 쿼리를 반복했을 때, 이전에는 없던 행이 새로 나타나는 현상**입니다.

예시)

```sql
-- 트랜잭션 A
SELECT * FROM orders WHERE amount > 100; -- 2건
-- 트랜잭션 B가 새로 INSERT
INSERT INTO orders (amount) VALUES (200);
-- 다시 트랜잭션 A에서 SELECT → 3건 (Phantom 발생)
```

- Gap Lock의 역할
	- InnoDB에서는 **REPEATABLE READ**에서도 Phantom Read를 막기 위해 **Gap Lock(간격 잠금)** 사용합니다.
	- **존재하지 않는 레코드 사이의 범위에도 락을 걸어**, 다른 트랜잭션이 새로 삽입하지 못하게 합니다.
28. **Undo / Redo Log**
29. **WAL (Write-Ahead Logging)**
30. **Force / No-Force 정책**
31. **Steal / No-Steal 정책**
32. **Checkpoint**
33. **Recovery Manager (Crash Recovery 단계)**
