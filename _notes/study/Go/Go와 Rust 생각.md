

## Rust


- DB Transaction 이 발생하는 백엔드는 굳이 러스트로 만들 필요가 있을까?
- 고성능, 높은 동시성 처리의 Rust를 OLTP시스템에 트랜잭션을 사용하면 성능 병목이 DB I/O에서 발생 했을때 Rust의 장점을 제대로 활용할 수 없다
- Rust는 고성능, 높은 동시성 처리에 강하지만, OLTP(Online Transaction Processing) 시스템처럼 DB 트랜잭션 중심의 백엔드에서는 병목이 대부분 DB I/O에서 발생하기 때문에 Rust의 장점을 제대로 살리기 어렵다.

### CASE Rust를 왜 OS에서 사용할까?

- 현대 OS 시스템에서 멀티 프로그래밍 정도를 극한으로 올릴 수 있는 OS에 Rust를 사용한다.

#### 왜 OS나 시스템 프로그래밍에 Rust가 잘 맞을까?

1. 메모리 안전성 보장 (no segfault, no UAF)
    - C/C++은 포인터 실수 한 번이면 커널 패닉
    - Rust는 컴파일 타임에 안전성 검사 → 시스템 전체의 안정성 증가
2. 고성능 + 저수준 제어력
    - Rust는 C 수준의 성능을 제공하면서도
    - inline assembly, 직접적인 하드웨어 제어도 가능
3. 멀티스레드 안정성
    - OS에서 중요한 동시성 제어를
    - Rust는 데이터 레이스 자체를 원천 차단 (컴파일 타임에!)
4. zero-cost abstraction
    - 고수준 문법을 써도 런타임 비용이 없음 → 깔끔한 코드 + 빠른 실행


#### 멀티프로그래밍 극한 추구 → Rust

- 멀티프로그래밍이 많을수록 → 공유 메모리, 동시성, 자원 경쟁이 핵심 이슈
- 이걸 C/C++로 하면 락, 뮤텍스, 세마포어 지옥이 기다리지만…
- Rust는 타입 시스템으로 그 위험을 원천 차단해줍니다

## Go

- 웹 백엔드에서 Go는 굉장히 강력하다. 경량형 스레드기반과 높은 동시성처리 유저 스레드와 커널 스레드 M to M 모델을 통한 코루틴과 스케줄링 최적화로 멀티 스레드 성능을 극한으로 끌어올려준다.
- CPU Intensive한 작업은 Go를 통해서 사용하고 Non Blocking I/O 작업은 NodeJS를 구성하는 방식이 아마 당근마켓에서 지향했던 아키텍쳐가 아닌가 싶다.

