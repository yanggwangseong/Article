---
title: 2-애플리케이션계층
permalink: /cs/network/top-down-approach/2-애플리케이션계층
tags:
  - Network
layout: page
---

- 애플리케이션 Layer란?
	- 네트워크 통신간에 통신을 위한 프로토콜과 인터페이스 방법을 추상화한 레이어.
- 프로토콜이란?
	- **통신간의 메시지를 교환하고 처리하는 규칙과 절차를 정의하는 통신규약** 
- [URL이란?](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_URL) 
	- 인터넷에 있는 고유한 리소스의 주소
- [Domain Name이란?](https://developer.mozilla.org/en-US/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_domain_name) 
- HTTP (HyperTextTransportProtocol)
	- **애플리케이션 Layer에서 데이터를 주고 받기 위한 stateless 프로토콜**
	- HTTP 메소드란?
		- request 목적과 request가 성공 했을때 예상되는 결과를 나타내는 메소드
	- HTTP 메소드 종류
		- GET - 세이프, 멱등, 캐셔블
		- POST - 논세이프, 논멱등, 논캐셔블
		- DELTE - 논세이프, 멱등, 논캐셔블
		- PUT: 새로운 리소스를 생성하거나 request 요청 보낸 콘텐츠로 변경.(멱등함, 논세이프, 논캐셔블)
		- PATCH : 부분적인 수정사항을 적용. (논세이프, 논멱등, 논캐셔블)
	- HTTP 메소드 특징
		- Safe(안전) - 서버 상태를 변경하지 않는 읽기전용 메소드
		- Idempotent(멱등성) - 동일한 여러번의 요청을 했을때 동일한 경우
		- Cacheable(캐시) - 동일한 요청이 있을 때 다시 서버에 요청하지 않고 캐시된 데이터를 재사용
- HTTP connections
	- non-presistent HTTP (비연결)
		- request를 보내고 response 받으면 연결을 종료하는 짧은 커넥션 방법
		- 기본 HTTP 1.0에서 사용
		- [MDN에서는 Short-lived connection 이라고함](https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x#short-lived_connections) 
	- presistent HTTP (연결)
		- HTTP 1.1에서 사용
	- [Pipelining (파이프 라이닝)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x#http_pipelining) 
		- HTTP/2에서 사용
	- [domain_sharding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x#domain_sharding) (도메인 샤딩)
		- [현대에서는 HTTP2의 CONNECTION COALESCING을 사용한다.](https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/) 
- HTTP/1.x 한계
	- 병렬 처리의 비효율성과 [Head-of-line Blocking 문제](https://developer.mozilla.org/en-US/docs/Glossary/Head_of_line_blocking) 
- HTTP/2
	- Multiplexing
	- Multiplexing을 통해서 Head-of-line Blocking 문제가 애플리케이션 Layer에서는 해결이 되었지만 transport (TCP)Layer에는 여전히 존재함.
- HTTP/3
	- UDP 기반의 QUIC 프로토콜
- [HTTP messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages) 
- [HTTP Content negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)
- [HTTP Compression](https://developer.mozilla.org/en-US/docs/Web/HTTP/Compression) 
	- 3가지
	- [File format compression](https://developer.mozilla.org/en-US/docs/Web/HTTP/Compression#file_format_compression) 
- [웹캐시](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching) 
	- 웹 캐시
		- coherence(일관성 문제)
		- 캐시 검증
			- ETags
				- 리소스의 고유한 식별자 태그
				- 클라이언트는 서버에 `If-None-Match` 헤더로 해당 ETag 값을 보내어 리소스가 변경 되었는지 확인.
			- Last-Modefied
				- 리소스의 마지막 수정시간
				- `If-Modified-Since` 헤더로 해당 시간을 보내어 리소스 변경 여부 확인.
		- conditional GET(Reqeust) (조건부 GET 또는 요청)
			- 웹 캐시 사용시 일관성 문제를 예방 하기 위해서
				- 어떻게 해결 하는데?
					- `If-modified-since` 를 통해서 명시된 날짜 이후 수정된 경우에만 객체를 보내게 하여 일관성 문제를 해결한다.
- [HTTP Redirect](https://developer.mozilla.org/ko/docs/Web/HTTP/Redirections) 
	1. [Permanent redirections](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections#permanent_redirections)
	2. [Temporary redirections](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections#temporary_redirections)
	3. [Special redirections](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections#special_redirections)
- HTTP Authentication (HTTP 인증)
	- 인증 방식
		- [HTTP authentication framework](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8_http_%EC%9D%B8%EC%A6%9D_%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC) 
			- 서버가 클라이언트에게 401 응답코드를 가지고 응답하며, 최소한 한번의 시도에 포함된 [www-Authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate) 응답 헤더로 권한을 부여하는 방법에 대한 정보를 제공한다.
			- [Challenge-response authentication (시도-응답 인증)](https://developer.mozilla.org/ko/docs/Glossary/Challenge) 
				- 공격자가 이전 메시지를 듣고 나중에 다시 보내 원본 메시지와 동일한 자격 증명을 얻는 [Retry Attack](https://developer.mozilla.org/ko/docs/Glossary/Replay_attack) 방지
					- Retry Attack을 방지하기 위한 다이제스트와 kerberos,[retry-attack01](https://www.linkedin.com/advice/0/how-does-pkce-prevent-authorization-code-interception-attacks) , [retry-attack02](https://bluecheat.medium.com/oauth-2-1-pkce-%EB%B0%A9%EC%8B%9D-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-14500950cdbf) 
			- [Nginx와 Basic 인증으로 접근 제한하기](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#nginx%EC%99%80_basic_%EC%9D%B8%EC%A6%9D%EC%9C%BC%EB%A1%9C_%EC%A0%91%EA%B7%BC_%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0) 
				- Basic schemes로 인증하게 되면 base65로 복호화가 가능하기 때문에 HTTPS/TLS를 통해서 Basic scheme와 함께 사용하고 Ngnix로 한번더 제한 할 수 있습니다.
		- [Proxy authentication](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%9D%B8%EC%A6%9D) 
			- 프록시 서버가 유효하지 않은 인증 정보를 받는다면 401또는 407로 응답하여야 하고, 사용자는 새로운 요청을 보내거나 `Authorization` 헤더필드를 바꿀 수 있다.
			- [Proxy-Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authorization) 
			- [Proxy-Authenticate](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authenticate) 
			- [www-authenticate와 Proxy-authenticate 헤더](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#www-authenticate%EC%99%80_proxy-authenticate_%ED%97%A4%EB%8D%94) 
			- [Authorization과 Proxy-Authorization 헤더](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#authorization%EC%99%80_proxy-authorization_%ED%97%A4%EB%8D%94) 
		- [다이제스트 인증방식](https://feel5ny.github.io/2019/11/24/HTTP_013_01/) 
			- 일반적인 HTTP authentication framework에서 scheme를 [Digest](https://developer.mozilla.org/ko/docs/Web/HTTP/Authentication#digest) 를 사용한 방식.
		- [kerberos 인증방식](https://gruuuuu.github.io/security/kerberos/) 
	- Authentication schemes
		- Basic
		- Bearer
- 프록시서버
	- 프록시 서버란?
		- 인터넷 상의 여러 네트워크들에 접속할 때 중계 역할을 해주는 프로그램 또는 컴퓨터
		- 월드 와이드 웹(World Wide Web) 상의 컨텐츠에 쉽게 접근할 수 있도록 도와줍니다.
		- 프록시는 요청을 가로챈 뒤 응답을 되돌려줍니다.
	- forward proxy(포워드 프록시) : 인터넷상에서 어디로든지 요청을 전송해주는 프록시입니다.
	- reverse proxy(리버스 프록시) : 인터넷에서 요청을 받으면, 내부망 내의 서버로 전송해줍니다.
- [Range Request (범위 요청)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests) 
- [쿠키](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies) 
	- **서버가 사용자를 추적하기 위한 작은 데이터 조각** 
	- secure와 HttpOnly쿠키
		- *XSS(크로스 사이트 스크립팅 Cross-site scripting) 공격*
			- 공격자가 웹사이트에 악성 클라이언트 사이드 코드를 삽입할 수 있도록 하는 보안 취약점 공격
	- SameSite 쿠키
		- *CSRF (교차 사이트 요청 위조)*
			- CSRF란 사용자의 의도와 관계 없이 행해지는 공격 기법
			- Referer Check
				- 백엔드에서 request의 referer를 확인하여 도메인이 일치하는지 검증하는 방법.
			- RestAPI로의 구현
			- CSRF토큰사용
- [HTTP Header](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers) 
	- [General header](https://developer.mozilla.org/ko/docs/Glossary/General_header) 
	- [Request header](https://developer.mozilla.org/ko/docs/Glossary/Request_header) 
	- [Response header](https://developer.mozilla.org/ko/docs/Glossary/Response_header) 
	- [Entity header](https://developer.mozilla.org/ko/docs/Glossary/Entity_header) 
- HTTP 보안
	- [CORS](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS) (교차 출처 리소스 공유)
		- **브라우저가 자신의 출처가 아닌 다른 출처로부터 자원을 로딩하는것을 허가 해주는 HTTP 헤더기반 메커니즘**
		- 어떻게 허가해주나요?
			- [Simple requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests) 
				- HTTP 헤더의 [Access-Control-Allow-Orign](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 를 옵트인 하는방법
				- `<form>` HTML4.0에서 심플 리퀘스트가 가능하기 때문에 서버는 CSRF로부터 보호해야 한다.
				- HTTP safe 메서드 사용시
			- Preflight request란?
				-  특정 메서드와 헤더를 사용하여 CORS 프로토콜이 이해되는지와 서버가 인식하고 있는지 확인하는 request
			- [Preflight request](https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request) 를 통해서 클라이언가 서버에 요청을 허용할지 요청한다.
			- [OPTIONS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/OPTIONS) 라는 HTTP 메서드를 사용.
			- HTTP 헤더의 [Access-Control-Allow-Orign](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin) 
			- 사용자 커스텀 헤더 또는 HTTP non-safe 메서드 사용시
	- CSP
	- HTTPS
		- http프로토콜에 SSL/TLS을 적용시킨 암호화 프로토콜
		- TLS란
			- SSL 암호화보다 훨씬 개선된 버전으로 등장한 암호화 프로토콜.
			- 핸드세이크 과정에서 보다 현대적인 알고리즘 SHA256 등 사용.
		- SSL(Secure Sockets Layer)/TLS란
			- 클라이언트와 서버가 서로 데이터를 암호화해 통신 할 수 있도록 돕는 계층.
			- 대칭키와 비대칭키
				- 대칭키
					- 하나의 키로 암호화와 복호화를 둘 다 할 수 있는 암호화 기법
					- *키를 안전하게 교환하기 어렵다는 단점이 있다*
					- 중간에 공격자가 가로치기 할 위험이있다.
				- 비대칭키(공개키)
					- 서로 다른 키 두개로 암호화, 복호화를 한다.
					- 공개키는 누구나 가질 수 있는 키이지만 개인키는 소유자 한명만 가질 수 있는 키로 한쌍으로 동작.
		- SSL/TLS 동작 과정
			- 핸드 세이크
			- 세션
			- 세션 종료
		- [End-to-End Encryption](https://kadirosmanust.medium.com/end-to-end-encryption-in-the-browser-5a1345aeb6e9) 

- [MDN HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP) 
- [네트워크 탑다운 어프로치 책](https://product.kyobobook.co.kr/detail/S000003156025) 
- [HTTP 기본인증](https://feel5ny.github.io/2019/11/23/HTTP_012_01/) 
- [HTTP와 Presistent Connection의 작동 원리](https://f-lab.kr/insight/http-and-persistent-connection) 
- [OAuth 2.0 공식문서](https://oauth.net/2/) 
- [HTTP/2 공식문서](https://http2.github.io/) 
- [TLS 암호화 동작과정](https://babbab2.tistory.com/4) 
- [Authentication Authorization Best practices](https://auth0.com/docs/get-started/authentication-and-authorization-flow) 
