---
title: 5장 네트워크 계층 Control Plane
permalink: /cs/network/top-down-approach/5장 네트워크 계층 Control Plane
tags:
  - Network
layout: page
---
# DistanceVector (거리 벡터) 알고리즘

Link State Algorithm은 네트워크 전체 정보를 이용
Distance Vector Algorithm은 *반복적이고 비동기적이며 분산적*이다.

- `분산적(distributed)` : 각 노드는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고, 계산을 수행하며, 계산된 결과를 다시 이웃들에게 배포한다.
- `반복적(iterative)` : 이웃끼리 더 이상 정보를 교환하지 않을 때까지 프로세스가 지속된다.
- `비동기적(asynchronous)` : 모든 노드가 서로 정확히 맞물려 동작할 필요가 없다.


## 책에서의 개념

- 각 이웃 노드 v중에서 x에 직접 접속된 이웃 노드까지의 비용 c(x, y)
- 노드 x의 DV, 즉 x로부터 N에 있는 모든 목적지 y로의 비용 예측값을 포함하는 벡터 `Dx = [Dx(y): y in N]` 
- 이웃 노드들의 거리 벡터들, 즉 v가 x의 이웃이라고 하면 `Dv = [Dv(y): y in N]` 


**DV 알고리즘에서는 어떤 노드 x가 자신에게 직접 연결된 링크 중 하나의 비용이 변경된 사실을 알게 되거나 어떤 이웃으로부터 변경된 거리 벡터를 수신했을 때 자신의 거리 벡터 추정값을 갱신한다** 

## 핵심 코어 개념

![[Pasted image 20250307134241.png]]

DV 알고리즘은 *벨만포드 알고리즘* 이라고 부른다. 위의 공식은 x에서 y까지의 최단거리를 구하는 벨만포드식이다.

> 공식만 보면 어려워 보이지만 이는 생각보다 간단한 공식이다.

![[Pasted image 20250307134517.png]]

- 메커니즘 자체는 결국 X에서 Y까지의 최단거리를 이동하는 방법에 대해서 구하는게 목적이고 이를 포워딩 테이블에 `update` 해주기 위한 알고리즘이다.
- 위의 그림에서 보면 X에서 Y까지 가기 위해서 중간에 수많은 라우터들과 AS들과 ISP들이 존재 한다.
- 여기서 벨만포드 알고리즘은 X기준에서 바라 봤을 때 즉, Y까지 가는 경로를 X 관점에서 바라보면 경로는 3가지이다.
- `X -> A , X -> B, X -> C` 즉, 이 말은 X에서 Y까지 가는 최단 거리는 3가지 경로중에 하나라는 뜻이다.
- 그걸 수식화 한것이 위의 그림인 `Dx(Y) = minv { c(x,y) + Dv(Y) }` 인것이다.

### 어떻게 동작할까?

![[Pasted image 20250307135151.png]]

1. `X` 라우터 입장에서 자신의 인접한 라우터들의 링크 가중치는 알고 있기 때문에 `X` 기준에서 A, B, C의 값을 구한다.
2. 그리고 이후는 수식으로 남겨 두는데 이 수식의 결과값만 채운다면 X에서 Y까지의 최단거리를 구할 수 있다.
3. 뒤의 수식의 결과값을 알려주는 역할은 이제 `X` 기준으로 인접한 라우터인 `A, B, C` 가 알려 주는것이다.

- `Dx(Y) = minA { c(x,y) + DA(Y) }`  -> `Dx(Y) = minA { 1 + DA(Y) } ` 
- `Dx(Y) = minB { c(x,y) + DB(Y) }`  -> `Dx(Y) = minB { 2 + DA(Y) } ` 
- `Dx(Y) = minC { c(x,y) + DC(Y) }`  -> `Dx(Y) = minC { 3 + DA(Y) } ` 

**즉, 뒤에 수식은 DA(Y), DB(Y), DC(Y) A, B, C 관점에서 Y까지의 경로들을 X에서 구한것과 동일하게 식으로 구하여서 그 결과값을 X에게 update 해주게 되면 최종적으로 X -> Y 까지의 최단거리를 구할 수 있다** 

- 이러한 재귀적인 구조를 가지고 있기 떄문에 DV의 특성중에서 `iterative` 하다는것이다.


## DV 알고리즘 동작 결과와 포워딩 테이블

![[Pasted Image 20250307133315_913.png]]

- 궁금증) forwarding table은 라우터에 있는 하드웨어장치인걸로 이해 했다. DV에서 각 라우터 관점에서 구하는 노드 테이블은 하드웨어 장치일까? 소프트웨어 자료구조 일까
	- ~~*소프트웨어적인 자료구조다* 즉, `Control Plane` 영역에서 관리한다. (라우터의 RAM)~~
	- gpt 틀린정보 각각의 라우터마다 포워딩 테이블 엔트리로 관리하고 `update` 한다.
	- 노드 테이블 === 포워딩 테이블

### 벨만포드 공식

- 노드 계산과 갱신의 생성 및 수신이 아무때나 `async` 이루어져도 올바르게 동작한다.
- `x` 가 최초 라우팅 테이블이라고 가정


```
// x 기준
Dx(x) = 0
Dx(y) = min { c(x, y) + Dy(y), c(x, z) + Dz(y) } = min { 2 + 0, 7 + 1} = 2
Dx(z) = min { c{x, y} + Dy(z), c(x, z) + Dz(z) } = min { 2 + 1, 7 + 0} = 3
```

### Forwarding Table

```
x table

|   | x | y | z
| x | 0 | 2 | 7
| y | & | & | &
| z | & | & | &

y table

|   | x | y | z
| x | & | & | &
| y | 2 | 0 | 1
| z | & | & | &

z table

|   | x | y | z
| x | & | & | &
| y | & | & | &
| z | 7 | 1 | 0

// 1SET DV
x table

|   | x | y | z
| x | 0 | 2 | 7
| y | 2 | 0 | 1
| z | 7 | 1 | 0

y table

|   | x | y | z
| x | 0 | 2 | 7
| y | 2 | 0 | 1
| z | & | & | &

z table

|   | x | y | z
| x | & | & | &
| y | & | & | &
| z | 7 | 1 | 0

```


## 링크 상태 알고리즘과 거리 벡터 라우팅 알고리즘의 비교

### ✅ 경로 계산 방법


LS와 DV 알고리즘은 경로를 계산할 때 서로 대비되는 방법을 취한다.

  

#### LS 알고리즘


- 전체 정보를 필요로 한다.
- 각 노드는 다른 **모든** 노드와 (브로드캐스트를 통해) 통신한다.
- **오직** 자신에게 직접 연결된 링크의 비용만 알린다.

  

#### DV 알고리즘


- 각 노드는 **오직** 직접 연결된 이웃과만 메시지를 교환한다.
- 자신으로부터 네트워크 내 (자신이 알고 있는) **모든** 노드로의 최소 비용 추정값을 이웃들에게 제공한다.

  

### ✅ 메시지 복잡성

#### LS 알고리즘


- 각 노드는 네트워크 내 각 링크 비용을 알아야 하며, 이를 위해서는 `O(|N| |E|)`개의 메시지가 전송되어야 한다.
- 링크 비용이 변할 때마다 새로운 링크 비용이 모든 노드에게 전달되어야 한다.

  

#### DV 알고리즘

- 매번 반복마다 직접 연결된 이웃끼리 메시지를 교환한다.
- 알고리즘의 결과가 수렴하는 데 걸리는 시간은 많은 요소에 좌우된다.
- 링크 비용이 변하고, 이 새로운 링크 비용이 이 링크에 연결된 어떤 노드의 최소 비용 경로에 변화를 준 경우에만  
    DV 알고리즘은 수정된 링크 비용을 전파한다.


### ✅ 견고성

라우터가 고장나거나 오동작하거나 파손된다면 어떤 일이 발생할까?

  

#### LS 알고리즘


- 라우터는 연결된 링크에 대해 잘못된 비용 정보를 브로드캐스트할 수 있다.
- 노드는 링크 상태 브로드캐스트를 통해 받은 패킷을 변질시키거나 폐기할 수 있다.

그러나 **하나의 링크 상태 노드는 자신의 포워딩 테이블만 계산하기 때문에** 링크 상태 알고리즘에서 경로 계산은 어느 정도 분산되어 수행된다.

따라서 링크 상태 알고리즘은 어느 정도의 견고성을 제공한다.

  

#### DS 알고리즘


- 노드는 잘못된 최소 비용 경로를 일부 혹은 모든 목적지에 알릴 수 있다.

각 반복마다 한 노드의 거리 벡터 계산이 이웃에게 전달되고 다음 반복에서 이웃의 이웃에게 간접적으로 전달된다.

따라서 거리 벡터 알고리즘을 사용하는 네트워크에서 한 노드의 잘못된 계산은 **전체로 확산될 수 있다.**

  

실제로 1997년에 작은 ISP에서 오작동한 라우터가 잘못된 라우팅 정보를 전국망의 백본 라우터에 제공한 적이 있었다.

이는 다른 라우터들이 오작동한 라우터에게 대규모 트래픽을 보내게 만들었고,  
인터넷의 상당 부분이 여러 시간 동안 단절되었다고 한다.

# RIP

- Hop Count를 라우팅 메트릭으로 사용하여 소스와 대상 네트워크 간의 최적 경로를 찾는 라우팅 프로토콜

### 홉 카운트란 무엇인가요?

홉 카운트는 소스와 대상 네트워크 사이에서 발생하는 라우터의 수입니다. 홉 카운트가 가장 낮은 경로는 네트워크에 도달하는 가장 좋은 경로로 간주되므로 라우팅 테이블에 배치됩니다. RIP는 소스에서 대상까지의 경로에서 허용되는 홉을 제한하여 라우팅 루프를 방지합니다. RIP에 허용되는 최대 홉 카운트는 15이고 홉 카운트가 16이면 네트워크에 도달할 수 없는 것으로 간주됩니다.

# OSPF

네트워크를 동일한 라우팅 알고리즘을 수행하는 동종의 라우터 집합으로 간주하는 관점은 두 가지 문제점이 존재한다.

1. 확장
	- 라우터의 수가 증가함에 따라 라우팅 정보의 통신, 계산, 저장에 필요한 오버헤드가 커진다.
2. 관리 자율성
	- ISP는 일반적으로 자신의 네트워크를 원하는 대로 운용하거나 (어떠한 라우팅 알고리즘이라도 수행할 수 있도록), 네트워크 내부 구성을 외부에 감추기를 원한다.

## Autonomous System (AS)

위의 문제점들은 라우터들을 AS (자율 시스템)으로 그룹화하여 해결 할 수 있다.

- 각 AS는 동일한 관리 제어하에 있는 라우터의 그룹으로 구성된다.
- 자율 시스템은 전 세계적으로 고유한 ASN(autonomous system number)로 식별된다.
- 같은 AS 안에 있는 라우터들은 동일한 라우팅 알고리즘을 사용하고 상대방에 대한 정보를 갖고 있다.
- 자율 시스템 내부에서 동작하는 라우팅 알고리즘을 AS 내부 라우팅 프로토콜 (Intra-autonomous system routing protocol) 이라고 한다.

## Open Shortest Path First (OSPF) 라우팅

OSPF(개방형 최단 경로 우선) 라우팅과 IS-IS(Intermediate System to Intermediate System) 는 인터넷에서 AS 내부 라우팅에서 널리 사용된다.

OSPF는 링크 상태 정보를 플러딩(flooding)하고 다익스트라 최소 비용 경로 알고리즘을 사용하는 Link State 알고리즘을 사용한다.

- OSPF를 이용하여 각 라우터는 전체 AS에 대한 완벽한 토폴로지 지도 (그래프)를 얻는다.
- 각 라우터는 자신을 루트 노드로 두고 모든 서브넷에 이르는 최단 경로 트리를 결정하기 위해 혼자서 다익스트라의 최단 경로 알고리즘을 수행한다.
- OSPF를 사용하는 라우터는 AS내의 다른 모든 라우터에게 라우팅 정보를 브로드캐스팅한다.
	- 링크 상태가 변경될 때마다
	- 링크 상태가 변경되지 않았더라도 정기적으로 (최소한 30분마다 한 번씩)
- OSPF 메세지에 포함된 상태 정보는 인터넷 프로토콜에 의해 전달되며, 상위 계층 프로토콜 번호로는 OSPF를 의미하는 `89` 를 갖는다.
	- 따라서 OSPF 프로토콜은 신뢰할 수 있는 메세지 전송과 링크 상태의 브로드캐스트와 같은 기능을 스스로 구현해야 한다.
	- 또한 OSPF 프로토콜은 링크가 동작하고 있는지 검사하고,
	- OSPF 라우터가 네트워크 전반의 링크 상태에 대한 이웃 라우터의 데이터베이스를 얻을 수 있도록 해야한다.

## OSPF 링크 가중치 설정

링크 상태 라우팅을 설명하면서 우리는 순서를 묵시적으로 아래와 같이 가정했다.

1. 링크 가중치가 설정되고,
2. OSPF 같은 라우팅 알고리즘이 수행되며,
3. LS 알고리즘에 의해 계산된 라우팅 테이블의 내용에 따라 트래픽이 흐른다.

이를 원인과 결과 방식으로 설명하면,

- 원인 : 링크 가중치가 주어지고
- 결과 : 이에 따라 전체 비용을 최소화하는 라우팅 경로가 결정된다.


실제로는 링크 가중치와 라우팅 경로 간의 원인과 결과 관계는 반대가 될 수 있다.
네트워크 운영자가 어떤 트래픽 관리 목표를 충족시키는 라우팅 경로를 얻기 위해 링크 가중치를 설정할 수 있다.

즉, 트래픽 흐름에 대한 바람직한 경로가 알려져 있고, OSPF 라우팅 알고리즘이 이 경로대로 구성하게 되도록 OSPF 링크 가중치를 찾아야 한다.

따라서 관리자는 모든 링크 비용을 1로 설정함으로써 최소 홉 라우팅이 이루어지게 하거나, 적은 대역폭을 가진 링크 사용을 억제하기 위해 링크 용량에 반비례하게 링크 가중치를 설정할 수 있다.

### OSFP에 구현된 개선사항들

#### 보안

OSPF 라우터들 간의 정보 교환(e.g., 링크 상태 갱신)을 인증할 수 있으며,  
인증을 통해 신뢰할 수 있는 라우터들만이 AS 내부의 OSPF 프로토콜에 참여할 수 있다.

원래 라우터 간의 OSPF 패킷은 인증을 하지 않으므로 위조될 수 있다.

두 종류의 인증

- 단순 인증 : 동일한 패스워드가 각 라우터에 설정되며, 라우터가 OSPF 패킷을 보낼 때 패스워드를 평문 그대로 포함하기 때문에 안전하지 않다.
- MD5 인증 : 모든 라우터에 설정된 공유 비밀키를 기반으로 한다. _(8장 내용)_

#### 복수 동일 비용 경로

하나의 목적지에 대해 동일한 비용을 가진 여러 개의 경로가 존재할 때 OSPF는 여러 개의 경로를 사용할 수 있도록 한다.

즉, 비용이 동일한 여러 개의 경로가 있을 때 **모든 트래픽을 전달하기 위한 단 하나의 경로를 선택할 필요가 없다.**

#### 유니캐스트와 멀티캐스트 라우팅의 통합 지원


`MOSPF(multicast OSPF)`는 멀티캐스트 라우팅 기능을 제공하기 위해 OSPF를 단순 확장했다.

- 기존의 OSPF 링크 데이터베이스를 사용
- OSPF 링크 상태 브로드캐스트 메커니즘에 새로운 형태의 링크 상태 알림을 추가

#### 단일 AS 내에서의 계층 지원

OSPF의 자율 시스템(AS)는 계층적인 영역(area)으로 구성될 수 있다.

- 각 영역은 자신의 OSPF 링크 상태 라우팅 알고리즘을 수행한다.
- 한 역역 내의 라우터는 **같은 영역 내의 라우터들에게만** 링크 상태를 브로드캐스트한다.
- 각 영역 내에서 하나 혹은 그 이상의 `영역 경계 라우터(area border router)`가 **영역 외부로의 패킷 라우팅을 책임진다.**
- `백본 영역`의 주요 역할은 AS 내 영역 간의 트래픽을 라우팅하는 것이다.

AS 내 영역 간 라우팅을 위해서는,

1. 영역 경계 라우터로 패킷을 라우팅한다. (영역 내 라우팅)
2. 백본을 통과하여 목적지 영역의 영역 경계 라우터로 라우팅한다.
3. 그 후 최종 목적지로 라우팅한다.

# BGP

Border Gateway Protocol
: AS간의 라우팅 프로토콜
전세계의 모든 ISP들을 연결하는 인터넷 프로토콜

- Hierarchical routing
- Inter AS

## BGP 역할

- 목적지가 AS외부에 있는 경우 AS Intra 프로토콜로 목적지를 결정 할 수 없다.
- iBGP를 통해서 같은 AS간에 다른 AS의 목적지를 알려주는 역할을 한다.
	- 즉, AS intra 프로토콜인 RIP와 OSPF과 iBGP의 차이점이 이것이다.
- CIDR 형식으로 표현된, Prefix를 향해 전달된다.
	- Hierarchical routing

### 기능

1. 이웃 AS를 통해 도달 가능한 Subnet Prefix 정보를 얻는다.
	- 특히 각 서브넷이 자신의 존재를 인터넷 전체에 알릴 수 있도록 한다.
2. 서브넷 주소 Prefix의 가장 좋은 경로를 결정한다.
	- 라우터는 특정한 주소 Prefix를 향한 2개 이상의 경로를 알 수 있다.

## BGP 경로 정보 알리기

![[Pasted image 20250306142638.png]]

- Gateway Router
- Internal Router

### BGP connection

![[Pasted image 20250306115413.png]]

- *BGP connection* : BGP에서 라우터의 쌍들은 포트 번호가 `179`이고 `반영구적인 TCP 연결`을 통해 라우팅 정보를 교환한다.
- 이 TCP 연결을 통해 모든 BGP 메시지가 전송된다.

external BGP (eBGP) 연결

- 2개의 AS를 연결하는 BGP 연결

internal BGP (iBGP) 연결

- 같은 AS 내의 라우터를 연결하는 BGP 연결
- **iBGP는 항상 물리적인 링크와 일치하지 않는다** 


- AS3의 x의 도착 정보를 AS1과 AS2에게 알리는 예제

## Determining the Best Routes

> 주어진 라우터에서 목적지 서브넷까지 많은 경로가 있을 수 있다.
> 이런 경로들 중에서 라우터가 최적의 경로를 선택하고 어떻게 포워딩 테이블을 설정할까?


![[Pasted image 20250306144132.png]]

AS1 부터 서브넷 x까지의 경로 2가지

- AS-PATH : "AS2 AS3"
- AS-PATH : "AS3"
- NEXT-HOP : 라우터 2a의 맨 왼쪽 인터페이스의 IP 주소 : "AS2 AS3; x"
- NEXT-HOP : 라우터 3a의 맨 왼쪽 인터페이스의 IP 주소 : "AS3; x"
- 목적지 주소 Prefix : "x"

### BGP Attribute

>  라우터가 BGP connection을 통해 prefix를 알릴 때 BGP attribute를 포함한다.

- AS-PATH
	- 메세지가 통과하는 AS들의 리스트를 담는다.
	- AS-PATH 값을 생성하기 위해 prefix가 어떤 AS에 전달 되었을 때
		- AS는 자신의 ASN을 AS-PATH 내 현재 리스트에 추가한다.
	- 메세지의 루프를 감지하고 방지하기 위해 활용
		- 어떤 라우터가 자신의 AS가 경로 리스트에 포함되어 있는 것을 발견하면 *그 알림 메세지를 버린다* 
- NEXT-HOP
	- **AS-PATH가 시작되는 라우터 인터페이스의 IP 주소다** 
	- *NEXT-HOP 속성이 같은 AS에 속하지 않는 라우터의 IP 주소라는점이 중요* 
- 목적지 주소 Prefix

## BGP Algorithm

### hot potato routing

- **가능한 모든 경로 중에서 경로 각각의 시작점인 NEXT-HOP 라우터까지의 경로 비용이 최소가 되는 경로가 선택된다.** 

![[Pasted image 20250306155428.png]]

1. NEXT-HOP 라우터 2a와 3d 각각에 대해 최소 비용을 가진 AS 내부 경로를 찾기 위해 AS 내부 라우팅 정보를 조사한다.
예시) 1b -> 2a 최소 비용
1b -> 2a (2)
예시) 1b -> 2d 최소 비용
1b -> 2d (3)
*2a가 선택된다* 

2. 라우터 1b는 AS intra 알고리즘을 통해서 포워딩 테이블을 관찰하여 라우터 2a로 가기 위한 인터페이스 I를 찾아낸다.
3. 엔트리 (x, I)를 자신의 포워딩 테이블에 추가한다.

> **포워딩 테이블에 AS 외부의 목적지를 추가할 때 AS간 라우팅 프로토콜(BGP)과 AS 내부라우팅 프로토콜 둘다가 사용된다는 점이 중요하다.**

*hot potato routing 알고리즘 핵심 메커니즘* 

![[Pasted image 20250306144132.png]]

- 목적지까지의 경로중 자신의 AS 외부에 있는 부분에 대한 비용은 고려하지 않고 가능한 최소 비용으로 빠르게 패킷을 자신의 AS 외부로 전달하는것이다.
- 즉, 오로지 자신의 AS 내부 비용만 줄이려는 이기적인 알고리즘이다.
- 예시에서 같은 AS내의 라우터들에서 같은 목적지 prefix까지 가는 최적의 경로가 다를 수 가 있다.
	- 라우터 1b는 AS2를 통해 서브넷 x로 전송.
	- 라우터 1d는 AS2를 거치지 않고 바로 AS3으로 보내 서브넷 x로 전송

### Route-Selection Algorithm

하나의 목적지에 2개이상의 경로가 존재 한다면 BGP는 하나의 경로가 남을때까지 다음과 같은 제거 규칙을 계속 수행한다.

![[Pasted image 20250306144132.png]]

*규칙* 

1. 속성(AS-PATH, NEXT-HOP)외에 local preference (지역 선호도)가 경로에 할당된다.
2. 최고 지역 선호 값을 가진 경로가 여러 개 있다면 이들 중에서 최단 AS-PATH를 가진 경로가 선택된다.
3. 같은 최고 지역 선호 값 및 같은 AS-PATH 길이를 가진 모든 남은 경로들에 대해서 hot potato routing 알고리즘 수행
4. 만일 아직도 하나보다 많은 경로가 남아 있다면 라우터는 BGP 식별자를 사용하여 경로를 선택한다.

EX)
라우터 1b에서 route selection 알고리즘을 사용하면 규칙 2가 규칙3보다 먼저 적용 되므로 **더 짧은 AS-PATH를 가진 AS2 우회 경로가 선택된다** 
그 결과 더이상 이기적인 알고리즘이 아니게 되고 결과적으로 end system 간의 latency가 줄어든다.


## IP anycast

- BGP는 IP anycast에서도 사용 되는데 이해를 위해서 CDN을 생각 하면 된다.
- 하지만 실제로는 CDN에서 사용하지 않고 보통 DNS에서 사용한다.
	- 왜 CDN에서 사용하지 않을까?
		- BGP 라우팅이 변경되면 하나의 TCP 연결에 속한 패킷들이 서로 다른 복제 웹 서버로 도착될 수 있기 때문이다.
	- DNS는 왜 사용할까?
		- DNS 질의를 가장 가까운 Root DNS Server로 전달하기 위해 IP anycast가 광범위하게 사용된다.
		- DNS 질의로 Root DNS Server에서 IP host를 얻는 과정일뿐이고 UDP이니 신뢰적인 전송하지 않는 작업이고 이를 가장 가까운 DNS 루트 서버에 전달 하기 위해 IP anycast를 사용하는것이다.

## Routing Policy

- **라우터가 목적지까지 경로를 선택 할때 AS Routing Policy은 최단 AS-PATH나 HotPotato 라우팅 등 모든 고려사항보다 항상 최우선이다** 
- **경로 선택 알고리즘의 지역 선호도의 속성의 값이 각 AS의 Policy에 의해 결정된다.**

![[Pasted image 20250306165606.png]]

- W, X, Y는 사용자 접속 ISP
- A, B, C는 backbone provider 네트워크

### CASE 1 : ISP access Network

- ISP access Network 조건
	- 모든 input 트래픽은 해당 네트워크가 목적지 주소여야한다.
	- 모든 output 트래픽은 해당 네트워크에서 생성된것이어야 한다.

X는 각기 다른 Provider Network통해서 네트워크의 다른 부분들과 연결되어 있는 *multi-homed access ISP* 다중 홈 접속 ISP라고 한다.

- X가 ISP access Network가 되기 위해서 Route Selection알림 방식을 사용하여 인접한 B,C에게 목적지는 자기 자신밖에 없다고 알림을 보내면 된다.

### CASE 2 : AS B에서 X에게 W까지의 경로를 알려주는 경우

> B가 X에게 BAW 경로를 알려줄 수 있다.
> 그러나 C에게도 BAW 경로를 알려줄 필요가 있을까?

A, B, C가 모두 Provider Network AS라면 B입장에서 Y에서 W까지 경로에 대한 책임을 져서는 안된다.
보통 일반적으로 Y는 B의 Cutomer Network가 아니기 때문에 C가 Y에게 W까지의 경로에 대한 책임을 가지는것이 일반적이다.


### 현실에서 책임

- **각각의 Provider Network에서 흐르는 모든 트래픽은 해당 ISP의 Cutomer Network를 출발지로 하거나 목적지로 해야한다.**


## 왜 INTER AS와 INTRA AS 라우팅 프로토콜이 다를까?

- Policy
	- INTER AS는 AS간의 정책 이슈로 인해서 특정 AS에서 시작한 트래픽이 다른 AS에 통과 할 수 없을 수 있다.
	- INTRA AS는 AS 안에서 모든것이 동일한 관리 통제하에 있기 때문에 Policy 이슈를 고려하지 않아도 된다.
- Scale
	- INTER AS에서는 경로 설정을 처리하기 위한 라우팅 알고리즘과 자료구조 능력은 INTER AS에서 매우 중요한 문제다.
	- INTRA AS에서는 확장성이 중요하지 않다.
		- 하나의 ISP가 너무 커지면 이를 2개의 AS로 분리하고, 이 새로운 두 AS 사이에서 AS 간 라우팅을 수행 할 수 있다(OSPF가 하나의 AS를 여러 영역으로 나눠서 계층을 만드는것을 허용함)
- Performance
	- INTER AS는 Policy 지향형으로 라우터의 품질(경로의 성능 수준)은 부수적인 요소일뿐이다.
	- INTRA AS는 Policy을 고려하지 않고 경로의 성능 수준에 좀 더 초점을 두고 라우팅 한다.

# Reference

- [Cloudflare AS](https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-an-autonomous-system/) 
- [IBM RIP](https://www.ibm.com/docs/ko/i/7.4?topic=routing-information-protocol) 
- [IBM OSPF](https://www.ibm.com/docs/ko/i/7.4?topic=routing-open-shortest-path-first) 
- [RFC 1265 BGP](https://www.rfc-editor.org/rfc/rfc1265.html)
