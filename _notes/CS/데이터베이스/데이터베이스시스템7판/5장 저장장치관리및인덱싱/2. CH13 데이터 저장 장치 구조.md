---
title: 데이터 저장 장치 구조
permalink: /cs/database/database-system-7th/ch-13
tags:
  - Database
layout: page
---


- 고정 길이 레코드
- 가변 길이 레코드
- 파일에 레코드를 구성하는 방법
- row-oriented storage
- column-oriented storage

Magnetic Disk와 SSD는 **block(블록)** 구조를 이용하는 저장 장치이다.
즉, **데이터를 블록 단위로 읽거나 쓴다** 
데이터베이스는 일반적으로 블록보다 훨씬 작은 크기인 **record(레코드)** 를 처리한다.

- Physical Storage
	- Sector
	- Track
	- Cylinder
	- Page
- Logical Storage
	- Block
	- Record
	- File

- 대부분 데이터베이스는 레코드를 저장하기 위한 중간 계층으로 운영체제 파일을 사용하여 하부 블록의 세부 정보를 추상화한다.
- 그러나 데이터베이스는 블록 구조를 계속 사용해야 하는데, 이는 효율적인 접근을 보장하고 오류 발생 시 데이터의 복구가 가능하도록 하기 위해서이다.
	- 블록 구성에 따라 어떻게 개별 레코드를 파일에 저장 하는가?
- 레코드 집합이 있다면, 파일 구성에서 이러한 레코드를 어떻게 조직할지를 결정할 수 있다.
	- 파일 레코드를 구성하는 방법
		- EX) 어떤 키에 대해 정렬한 순서, 생성한 순서, 또는 임의 순서대로 레코드를 저장할 수 있는 것이다.
- 데이터 사전에서 데이터베이스가 저장 장치 구조뿐만 아니라 관계형 스키마에 대한 메타 데이터를 어떻게 구성하는가?
	- EX) 릴레이션의 이름이 주어졌을 때 릴레이션의 레코드를 찾고 검색하는 것과 같이, 데이터 사전의 정보는 많은 데이터 관리 작업에서 매우 중요하다.
- 보통 메인 메모리보다 큰 데이터베이스의 경우, **데이터를 비휘발성 저장 장치에서 가져와서 갱신한 뒤에는 다시 저장 장치에 저장해야 한다.**
	- 데이터베이스가 비휘발성 저장 장치에서 가져온 블록을 `데이터베이스 버퍼(buffer)`라고 하는 메모리 영역을 이용하여 저장하는 방법?
- 특정 행의 모든 속성을 함께 저장하는 것이 아니라, **특정 열의 모든 값을 함께 저장**하는 것에 기반을 둔 데이터 저장 방법은 분석 질의 처리에서 매우 잘 동작하는 것으로 밝혀졌다.
	- 열 지향 저장소(column-oriented storage)
- 전체 데이터베이스를 메모리에 상주(residency)를 활용하기 위해 데이터베이스에서 사용하는 인메모리 데이터 구조를 최적화한 데이터베이스
	- main-memory database
		- SCM(저장 장치급 메모리)라고 하는 개별 바이트 또는 캐시 라인에 직접 접근할 수 있는 비휘발성 메모리에서 더욱 최적화될 수 있다.

# File 구성

- block이라고 불리는 고정 길이(fixed-length) 저장 단위로 각 파일을 논리적으로 분할한다.
- 블록은 저장 장소할당과 데이터 전송의 단위이다.
- 한개의 블록은 여러 레코드를 포함한다.
- **단일 블록은 각 레코드를 완전히 포함해야한다** 
	- 어떤 레코드도 한 블록에 부분적으로 포함되거나 또 다른 레코드에 부분적으로 포함되지 않는다는 것을 의미한다.
	- 왜 이렇게 할까?
		- 데이터 항목에서 접근하는 것을 단순화하고 접근 속도를 향상시킨다.
- 관계형 데이터베이스에서 서로 다른 릴레이션의 튜플은 일반적으로 다른 크기를 가진다.


## Database File Mapping

- Fixed Length Record
- Variable Length Record

### Fixed Length Record

예시) 대학교 데이터베이스의 `instructor` 레코드 파일

```
type instructor = record
                    ID varchar(5);
                    name varchar(20);
                    dept_name varchar(20);
                    salary numeric(8, 2);
                  end
```

각 문자는 1바이트를, numeric(8, 2)형은 8바이트를 차지한다고 가정한다면, instructor 레코드의 길이는 53바이트다.

이러한 고정 길이 파일을 구성하는 간단한 방법은 첫 번째 레코드를 위해 첫 번째 53바이트를 사용하고,  
두 번째 레코드를 위해 그다음 53바이트를 사용하는 등등이다.


> Physical Storage, Logical Storage
> 블록, 파일, 레코드 헷갈리네.


### Variable Length Record


## 대형 객체 저장 방법

- 대형 객체 저장 방법 두가지
- 성능 이슈


# 파일 레코드를 구성하는 방법

> `relation(릴레이션) = record(레코드)들의 집합` 

- 힙 파일 구성, Heap file organization
- 순차 파일 구성, Sequential file organization
- 다중 테이블 군집 파일 구성, Multitable clustering file organization
- B+-트리 파일 구성, B+-tree file organization
- 해싱 파일 구성, Hashing file organization


## Heap file organization

- 레코드는 릴레이션에 해당하는 파일의 어디에나 저장될 수 있다.

### 레코드 삽입

- 레코드를 파일에 삽입할 때, 항상 파일의 끝부분에 추가하도록 할 수 있다.
- 그러나 **레코드를 삭제하면 만들어진 빈 곳을** 사용하여 새 레코드를 저장하는 것이 좋다.


### free-space map(여유 공간 맵)

- 대부분 데이터베이스는 여유 공간 맵(free-space map)이라고 하는 공간 효율적 데이터 구조를 사용하여 레코드를 저장할 여유 공간이 있는 블록을 추적한다.
- 여유 공간 맵은 릴레이션의 각 블록에 대해 한 개의 엔트리를 포함하는 배열로 흔히 나타낸다.
- 각 엔트리는 비율 f를 표현하는데, 이는 최소 비율 f만큼이 해당 블록 공간에 비어 있어야 한다는 것을 뜻한다.
- 레코드를 삽입, 삭제 또는 그 크기를 변경할 때마다 엔트리 값에 영향을 줄 만큼 점유 비율이 변경되면 여유 공간 맵에서 엔트리를 갱신한다.

#### 2계층 free-space map


## Sequential file organization (순차 파일 구성)

레코드의 효율적인 처리를 위해 일부 `검색 키(search key)`**를 기반으로 정렬한 순서로** `순차 파일(sequential file)`을 설계한다.

- **검색 키** 
	- `검색 키(search key)` 는 특정 속성이나 속성들의 집합으로, 정렬의 기준이 된다.
	- 반드시 주 키이거나 슈퍼 키일 필요는 없다.

### 레코드의 삭제와 삽입

레코드를 삽입하고 삭제한 대로 물리적 순서를 유지하기는 어렵다.
한 번의 삽입이나 삭제 때문에 많은 레코드를 이동하는 것은 비용이 많이 들기 때문이다.

### 레코드의 삭제

레코드의 삭제는 **포인터 체인** 을 이용하여 관리할 수 있다.


### 레코드의 삽입

1. 검색 키 순서로 볼 때 삽입할 레코드 바로 앞에 위치하는 레코드를 파일에서 찾는다.
2. (1) 찾은 레코드와 같은 블록 내에 빈 레코드(즉 삭제한 후 빈 공간)가 있다면 거기에 새로운 레코드를 삽입한다.
	- (2) 그렇지 않다면 `오버플로 블록(overflow block)`에 새로운 레코드를 삽입한다.
		- 어느 경우든, 레코드를 검색 키 순서로 연결하기 위해 포인터를 조정한다.

### File Reorganized (파일 재구성)

- 상대적으로 오버플로 블록에 저장할 필요가 있는 레코드가 거의 없다면 위의 방법은 잘 동작한다.
- 하지만 검색 키 순서와 물리적 순서 사이의 일치를 시간이 지남에 따라 완전히 잃어버릴 수가 있어, 이 경우 순차적인 처리가 훨씬 비효율적으로 될 수 있다.
- 이 시점에서는 다시 물리적으로 순차적인 순서가 되도록 파일을 `재구성(reorganized)`해야 한다.
	- 재구성 작업은 비용이 많이 든다.
	- 이 작업은 시스템 작업량이 낮을 때 해야 한다.
	- 재구성이 필요한 빈도는 새로운 레코드의 삽입 빈도에 따라 다르다

