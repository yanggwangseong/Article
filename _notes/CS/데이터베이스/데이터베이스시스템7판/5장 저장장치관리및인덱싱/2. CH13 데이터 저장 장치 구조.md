---
title: 데이터 저장 장치 구조
permalink: /cs/database/database-system-7th/ch-13
tags:
  - Database
layout: page
---


- 고정 길이 레코드
- 가변 길이 레코드
- 파일에 레코드를 구성하는 방법
- row-oriented storage
- column-oriented storage

Magnetic Disk와 SSD는 **block(블록)** 구조를 이용하는 저장 장치이다.
즉, **데이터를 블록 단위로 읽거나 쓴다** 
데이터베이스는 일반적으로 블록보다 훨씬 작은 크기인 **record(레코드)** 를 처리한다.

- 대부분 데이터베이스는 레코드를 저장하기 위한 중간 계층으로 운영체제 파일을 사용하여 하부 블록의 세부 정보를 추상화한다.
- 그러나 데이터베이스는 블록 구조를 계속 사용해야 하는데, 이는 효율적인 접근을 보장하고 오류 발생 시 데이터의 복구가 가능하도록 하기 위해서이다.
	- 13.2절) 블록 구성에 따라 어떻게 개별 레코드를 파일에 저장 하는가?
- 레코드 집합이 있다면, 파일 구성에서 이러한 레코드를 어떻게 조직할지를 결정할 수 있다.
	- 13.3절) 파일 레코드를 구성하는 방법
		- EX) 어떤 키에 대해 정렬한 순서, 생성한 순서, 또는 임의 순서대로 레코드를 저장할 수 있는 것이다.
- 13.4절) 데이터 사전에서 데이터베이스가 저장 장치 구조뿐만 아니라 관계형 스키마에 대한 메타 데이터를 어떻게 구성하는가?
	- EX) 릴레이션의 이름이 주어졌을 때 릴레이션의 레코드를 찾고 검색하는 것과 같이, 데이터 사전의 정보는 많은 데이터 관리 작업에서 매우 중요하다.
- 보통 메인 메모리보다 큰 데이터베이스의 경우, **데이터를 비휘발성 저장 장치에서 가져와서 갱신한 뒤에는 다시 저장 장치에 저장해야 한다.**
	- 13.5절) 데이터베이스가 비휘발성 저장 장치에서 가져온 블록을 `데이터베이스 버퍼(buffer)`라고 하는 메모리 영역을 이용하여 저장하는 방법?
- 특정 행의 모든 속성을 함께 저장하는 것이 아니라, **특정 열의 모든 값을 함께 저장**하는 것에 기반을 둔 데이터 저장 방법은 분석 질의 처리에서 매우 잘 동작하는 것으로 밝혀졌다.
	- 13.6절) 열 지향 저장소(column-oriented storage)
- 전체 데이터베이스를 메모리에 상주(residency)를 활용하기 위해 데이터베이스에서 사용하는 인메모리 데이터 구조를 최적화한 데이터베이스
	- 13.7절) main-memory database
		- SCM(저장 장치급 메모리)라고 하는 개별 바이트 또는 캐시 라인에 직접 접근할 수 있는 비휘발성 메모리에서 더욱 최적화될 수 있다.


# File 구성

하나의 데이터베이스는 내부적으로 기반 운영체제가 관리하는 많은 다른 파일에 대응하며, 이 파일은 디스크 안에 영구적으로 저장된다.

![](/assets/os-file-system-image15.png)

- **file(파일)** 은 일련의 레코드로서, 논리적으로 구성된다.
- block이라고 불리는 고정 길이(fixed-length) 저장 단위로 각 파일을 논리적으로 분할한다.
- 블록은 저장 장소할당과 데이터 전송의 단위이다.
	- 대부분의 데이터베이스는 기본으로 4~8KB의 블록 크기를 사용한다.
- 한개의 블록은 여러 **record(레코드)** 를 포함한다.
- 레코드는 여러 **field(필드)** 를 포함한다.
- **블록보다 더 큰 레코드는 없다** 고 가정한다
	- 이 가정은 대부분의 데이터 처리 응용 프로그램을 고려할 때 현실적이다.
	- 블록보다 훨씬 큰 대용량의 데이터 항목은 별도로 저장한 다음, 레코드 안에 해당 데이터 항목에 대한 포인터를 저장함으로써 다룬다.
- **단일 블록은 각 레코드를 완전히 포함해야한다** 
	- 어떤 레코드도 한 블록에 부분적으로 포함되거나 또 다른 레코드에 부분적으로 포함되지 않는다는 것을 의미한다.
	- 왜 이렇게 할까?
		- 데이터 항목에서 접근하는 것을 단순화하고 접근 속도를 향상시킨다.
- 관계형 데이터베이스에서 서로 다른 릴레이션의 튜플은 일반적으로 다른 크기를 가진다.


## Database File Mapping

- Fixed Length Record
	- 여러 파일을 사용하면서 주어진 파일내에 고정 길이 레코드만 저장한다.
- Variable Length Record
	- 파일을 구조적으로 저장하여 가변 길이로 레코드를 저장한다.

### Fixed Length Record

예시) 대학교 데이터베이스의 `instructor` 레코드 파일

```
type instructor = record
                    ID varchar(5);
                    name varchar(20);
                    dept_name varchar(20);
                    salary numeric(8, 2);
                  end
```

각 문자는 1바이트를, numeric(8, 2)형은 8바이트를 차지한다고 가정한다면, instructor 레코드의 길이는 53바이트다.

이러한 고정 길이 파일을 구성하는 간단한 방법은 첫 번째 레코드를 위해 첫 번째 53바이트를 사용하고,  
두 번째 레코드를 위해 그다음 53바이트를 사용하는 등등이다.

![](database-system13.png)

#### 2가지 문제점

1. 만약 블록 크기가 53의 배수가 되지 않는다면 몇몇 레코드는 블록 경계는 넘게 된다.
	- 즉, 레코드 일부분은 어떤 블록에 저장되고 나머지 부분은 다른 블록에 저장될 것이므로 해당 레코드를 읽거나 쓰기 위해서는 두 블록에 모두 접근 해야한다.
	- 이를 피하려면 한 블록에 완전히 채울 수 있는 만큼의 블록만 레코드를 할당해야 한다. (남은 바이트는 사용하지 않은 채 남김)
2. 레코드를 삭제하기 어렵다
	- 삭제 할 레코드가 차지하는 공간은 그 파일의 다른 레코드로 채우거나, 그 공간을 무시할 수 있도록 레코드를 삭제했다는 표시를 해야한다.

- 삭제 후에 링크드리스트로 연결해서 빠르게 빈공간을 찾아서 insert 할 수 있게 한다.
### Variable Length Record

Variable Length Record는 데이터베이스 시스템에서 레코드의 필드 길이가 가변적인 경우에 처리하기 위해서 사용 됩니다. 예로 문자열, 배열, Multisets등의 데이터 타입을 포함하는 레코드에서 사용 합니다.

#### 가변 길이 레코드를 구성하기 위해서 해결 해야 되는 2가지 문제점

- **각 개별 레코드에서 가변 길이 필드를 어떻게 저장할 것인가?**  
    → 특정 필드(예: `VARCHAR`)가 다른 필드보다 길 수 있기 때문에, **각 필드의 위치와 길이를 저장하는 방식이 필요**함.
- **블록 내에서 가변 길이 레코드를 어떻게 저장할 것인가?**  
    → 레코드가 가변 길이를 가지므로 블록 내에서 공간을 효과적으로 관리하는 구조가 필요함.

#### 가변 길이 레코드의 저장 방법

레코드를 저장할 때 **"고정 길이 부분"과 "가변 길이 부분"** 두 개로 나눠서 저장합니다.

- **고정 길이 부분**
    - 숫자형 데이터 (`int`, `float`, `date`) 등은 일정한 크기를 차지하므로 고정된 위치에 저장.
    - 각 필드가 어디서 시작하는지 저장하는 **offset (시작 위치)** 와 **length (길이)** 값을 포함.
- **가변 길이 부분**
    - 문자열(`VARCHAR`), 다중값(multisets) 등의 데이터는 고정 길이 부분 뒤에 연속적으로 저장.
    - 가변 필드는 **고정 길이 부분에서 저장된 offset과 length 값을 참고하여 접근**.

💡 **즉, 고정된 크기의 메타데이터(시작 위치, 길이)를 사용하여 가변 필드를 관리하는 방식!**

**예제: Instructor 테이블의 가변 길이 레코드 저장 방식**

- `ID`, `name`, `dept_name` 은 가변 길이 필드
- `salary`는 고정 크기 필드

```
// 데이터 저장 구조
| 21,5 | 26,10 | 36,10 | 65000 | 10101 | Srinivasan | Comp. Sci. |

```

- **Offset, Length 정보 (초기 4바이트)**
    - `ID` → 21번째 바이트부터 시작, 길이 5
    - `name` → 26번째 바이트부터 시작, 길이 10
    - `dept_name` → 36번째 바이트부터 시작, 길이 10
    - `salary`는 정수형 데이터(고정 크기)

🔹 **이렇게 하면 가변 길이 필드가 있어도 효율적으로 접근 가능!**

#### Null Bitmap (NULL 값 저장 방식)

데이터베이스에서는 일부 필드가 `NULL` 값을 가질 수 있습니다.  
이를 효율적으로 저장하기 위해 **NULL Bitmap**을 사용합니다.

**✅ NULL Bitmap의 개념**

- 각 필드가 NULL인지 아닌지를 **비트맵 형태(0/1)** 로 저장.
- 예를 들어, `4개의 필드`가 있는 경우 `0000`이면 **모든 필드에 값이 있음**,  
    `1000`이면 첫 번째 필드가 NULL이고 나머지는 값이 있음.
- **NULL 필드는 데이터 공간을 차지하지 않음** → 저장 공간 절약 가능.

#### Slotted Page 구조 (가변 길이 레코드 저장 방식)

가변 길이 레코드를 블록(페이지) 내에 효율적으로 저장하기 위해 **Slotted Page 구조**를 사용합니다.

**Slotted Page의 구조**

- **Block Header(헤더)**
    - **저장된 레코드 개수**
    - **남은 여유 공간 위치**
    - **레코드들의 위치 및 크기를 저장하는 배열**
- **레코드 영역**
    - **레코드들은 블록의 끝부분부터 채워짐.**
    - **레코드가 삭제되면 공간을 다시 정렬하여 채움.**

💡 **즉, 인덱스 테이블(헤더)을 통해 레코드 위치를 관리 하므로 가변 길이 레코드도 빠르게 검색 가능!**

 **Slotted Page 구조의 장점**

1. **레코드가 삭제되면 블록 내에서 공간을 정리하여 활용 가능**  
    → 삭제된 레코드의 공간을 바로 재사용할 수 있음.
    
2. **레코드의 위치가 변경되더라도, 헤더 정보만 업데이트하면 됨**  
    → 레코드를 찾는 포인터가 직접 레코드를 가리키지 않고 **헤더에 저장된 위치 정보를 통해 간접적으로 접근**.
    
3. **레코드 크기가 가변적이더라도 효율적으로 저장 가능**  
    → 새로운 레코드를 추가할 때 적절한 공간을 찾아 배치 가능.

- 가변 길이 레코드 저장
	- 고정 길이 부분 + 가변 길이 부분으로 나누어서 저장
- Offset, Length 사용
	- 필드의 위치와 크기를 저장하여 접근
- NULL Bitmap 사용
	- NULL 값이 있는 필드를 비트맵으로 저장 (공간 절약)
- Slotted Page 구조
	- 블록 내에서 레코드의 위치를 관리하는 인덱스 테이블 사용

Slotted Page 구조 덕분에 레코드의 위치가 변경되어도 직접 접근이 가능하다
NULL Bitmap 덕분에 NULL 필드가 있는 경우도 효율적으로 저장이 가능하다
Offset과 Length를 통해 가변 길이 데이터도 빠르게 검색 가능하다



## 대형 객체 저장 방법

- 대형 객체 저장 방법 두가지
- 성능 이슈

# 파일 레코드를 구성하는 방법

> `relation(릴레이션) = record(레코드)들의 집합` 

- 힙 파일 구성, Heap file organization
- 순차 파일 구성, Sequential file organization
- 다중 테이블 군집 파일 구성, Multitable clustering file organization
- B+-트리 파일 구성, B+-tree file organization
- 해싱 파일 구성, Hashing file organization

## Heap file organization

- 레코드는 릴레이션에 해당하는 파일의 어디에나 저장될 수 있다.

### 레코드 삽입

- 레코드를 파일에 삽입할 때, 항상 파일의 끝부분에 추가하도록 할 수 있다.
- 그러나 **레코드를 삭제하면 만들어진 빈 곳을** 사용하여 새 레코드를 저장하는 것이 좋다.


### free-space map(여유 공간 맵)

- 대부분 데이터베이스는 여유 공간 맵(free-space map)이라고 하는 공간 효율적 데이터 구조를 사용하여 레코드를 저장할 여유 공간이 있는 블록을 추적한다.
- 여유 공간 맵은 릴레이션의 각 블록에 대해 한 개의 엔트리를 포함하는 배열로 흔히 나타낸다.
- 각 엔트리는 비율 f를 표현하는데, 이는 최소 비율 f만큼이 해당 블록 공간에 비어 있어야 한다는 것을 뜻한다.
- 레코드를 삽입, 삭제 또는 그 크기를 변경할 때마다 엔트리 값에 영향을 줄 만큼 점유 비율이 변경되면 여유 공간 맵에서 엔트리를 갱신한다.

#### 2계층 free-space map

## Sequential file organization (순차 파일 구성)

레코드의 효율적인 처리를 위해 일부 `검색 키(search key)`**를 기반으로 정렬한 순서로** `순차 파일(sequential file)`을 설계한다.

- **검색 키** 
	- `검색 키(search key)` 는 특정 속성이나 속성들의 집합으로, 정렬의 기준이 된다.
	- 반드시 주 키이거나 슈퍼 키일 필요는 없다.

### 레코드의 삭제와 삽입

레코드를 삽입하고 삭제한 대로 물리적 순서를 유지하기는 어렵다.
한 번의 삽입이나 삭제 때문에 많은 레코드를 이동하는 것은 비용이 많이 들기 때문이다.

### 레코드의 삭제

레코드의 삭제는 **포인터 체인** 을 이용하여 관리할 수 있다.


### 레코드의 삽입

1. 검색 키 순서로 볼 때 삽입할 레코드 바로 앞에 위치하는 레코드를 파일에서 찾는다.
2. (1) 찾은 레코드와 같은 블록 내에 빈 레코드(즉 삭제한 후 빈 공간)가 있다면 거기에 새로운 레코드를 삽입한다.
	- (2) 그렇지 않다면 `오버플로 블록(overflow block)`에 새로운 레코드를 삽입한다.
		- 어느 경우든, 레코드를 검색 키 순서로 연결하기 위해 포인터를 조정한다.

### File Reorganized (파일 재구성)

- 상대적으로 오버플로 블록에 저장할 필요가 있는 레코드가 거의 없다면 위의 방법은 잘 동작한다.
- 하지만 검색 키 순서와 물리적 순서 사이의 일치를 시간이 지남에 따라 완전히 잃어버릴 수가 있어, 이 경우 순차적인 처리가 훨씬 비효율적으로 될 수 있다.
- 이 시점에서는 다시 물리적으로 순차적인 순서가 되도록 파일을 `재구성(reorganized)`해야 한다.
	- 재구성 작업은 비용이 많이 든다.
	- 이 작업은 시스템 작업량이 낮을 때 해야 한다.
	- 재구성이 필요한 빈도는 새로운 레코드의 삽입 빈도에 따라 다르다



## B+ tree file organization

- ch14-4 내용도 추가

