---
title: B+-트리 인덱스 파일
permalink: /cs/database/database-system-7th/ch-14-b-tree-index-file
tags:
  - Database
layout: page
---

# B +- 트리 인덱스 파일

## 인덱스 순차 파일의 단점

- 파일이 커질수록, 인덱스를 찾아서 그 데이터를 연속적으로 스캔하는 성능이 감소한다.
- 성능 감소는 파일을 재구성함으로써 제거될 수 있지만, 파일 재구성에 드는 비용은 크다.

## B+- tree index

- **B+- tree index** 구조는 데이터의 삽입과 삭제에도 불구하고 성능을 유지하는 몇몇 인덱스 구조 중 가장 널리 사용된다.
- 트리의 Root에서 Leaf 노드까지 모든 경로의 길이가 같은 **balanced tree** 균형 트리 형태다.
- root 노드를 제외한 비단말 노드는 **⎡n/2⎤~ n** 사이의 자식(children)을 가지고 있다.
	- 즉, 50% 이상이 차있어야 한다. ( n은 특정한 트리에 대한 고정된 값)
- leaf 노드는 **⎡(n-1)/2⎤~ n-1** 사이의 개수만큼 value를 가진다

**[이미지] instructor 파일의 B+-트리 (n = 4)**

![](/assets/database-system09.png)

이 구조는 삽입과 삭제 시 성능 부담과 공간 부담을 준다.
하지만 이 성능 부담은 파일의 변경이 많은 경우에 파일 재구성 비용을 피할 수 있기에 수용될 수 있다.

## B+-트리의 구조

![[Pasted image 20250313173827.png]]

- B+- 트리 인덱스는 다계층 인덱스이다.
- 중복 검색 키 값이 없다고 가정하자. 즉, 각각의 **search key(검색키)** 는 유니크하다.

**[이미지] 전형적인 B+- 트리 노드**

![](/assets/database-system10.png)

- n-1개의 검색 키 값 K
- n개의 포인터 P
- 노드 안의 검색 키 값은 **정렬된 순서** 로 유지된다.
- K1 < K2 < K3 < ... < Kn-1

### leaf node (단말 노드)

**[이미지] instructor B+-트리 인덱스의 leaf node (n = 4)**

![](/assets/database-system08.png)

- 포인터 Pi는 검색 키 값 Ki를 가지는 파일 레코드를 가리킨다.
- 적어도 ⎡(n-1)/2⎤개의 value를 포함해야 한다.

leaf 노드를 **검색 키 순서로 서로 연결하기 위해서** 포인터 Pn을 사용한다.
파일의 연속적인 처리에 대한 성능이 증가한다.

### non-leaf node (비단말 노드)

- internal node
- leaf 노드 상에서 **multi-level sparse index(다계층 희소 인덱스)** 를 형성한다.
- 모든 포인터가 **트리 노드에 대한 포인터** 인 것을 제외하고는 leaf노드의 구조와 동일하다.
- ⎡n/2⎤ ~ n개 사이의 개수만큼 포인터를 가질 수 있다. (한 노드의 포인터 수 : 그 노드의 팬아웃(fanout))

![](/assets/database-system10.png)

m(≤ n)개의 포인터를 포함하는 노드

- i = 2, 3, … , m-1일 때, 포인터 Pi는 **Ki 보다는 작고, Ki-1보다는 크거나 같은** 검색 키 값을 포함하는 서브 트리(subtree)를 가리킨다.
- 포인터 Pi는 **Ki 보다는 작고, Ki-1보다는 크거나 같은** 검색 키 값을 포함하는 서브 트리(subtree)를 가리킨다.
- 포인터 P1은 K1보다 작은 검색 키 값을 포함하는 서브 트리를 가리킨다.

**[그림] n=6인 instructor 파일의 B+-트리** 

![](/assets/database-system11.png)

- **Root Node(루트 노드)** 
	- 루트 노드에 2개의 키가 존재
	- **포인터 개수 = 키 개수 + 1 = 3** 즉, 3개의 자식을 루트노드는 가진다.
- Leaf Node
	- 리프 노드는 최대 n-1 = 5 개의 키를 저장 가능.
	- 최대 n-1 = 5개의 데이터를 포함할 수 있다.
- internal Node
	- 최대 n개(6개)의 자식을 가질 수 있다.
	- **B- Tree인 경우 최대 n-1 = 5개의 데이터를 포함할 수 있다**

# B+- 트리에서의 Query

- **Point queries** : `find(v)` 
- **Range queries** : `findRange(lb, ub)` 

![[Pasted image 20250313181708.png]]

B+-트리는 각 노드가 크고(일반적으로 디스크 블록 크기), 각 노드는 많은 수의 포인터를 가질 수 있다.

## B+- 트리 Point Query

 **현재 예제는 Search Key가 유니크인경우라고 가정한다** 

### B+- 트리에서 특정값 `v` 를 찾는 과정

1. Root 노드에서 시작
	- 루트 노드에 있는 Key들을 확인하면서 `v` 가 들어갈 위치를 찾습니다.
	- 키 값들을 탐색하면서, `v` 보다 크거나 같은 **가장 작은 키(Kᵢ)** 를 찾습니다.
	- 이 과정은 **이진 탐색(Binary Search)** 을 사용하여 빠르게 수행됩니다.
2. **어떤 자식 노드로 내려갈지 결정** 
	- 찾은 키 `Kᵢ`가 `v`와 같다면, `Kᵢ` 오른쪽 포인터 `Pᵢ₊₁` 로 이동.
	- `Kᵢ`가 `v`보다 크다면, 왼쪽 포인터 `Pᵢ`로 이동.
	- 만약 적절한 `Kᵢ`가 없다면 (즉, `v`가 현재 노드의 가장 큰 값보다 큼), 가장 오른쪽 포인터 `Pₘ`로 이동.
	- 이러한 과정을 반복하면서 **리프 노드(Leaf Node)까지 내려감**.
3. Leaf Node에서 최종적으로 `v` 를 검색
	- 리프 노드까지 도착한 후, 해당 노드에서 `v`를 찾습니다.
	- 찾으면 해당 데이터(레코드)의 위치를 반환하고, 없으면 `null` 반환.

**예시 find(35)를 실행한다고 가정**

```ts
            [30   50] // Root Node
           /       |       \
   [10  20]   [30  40]   [50  60] // Internal Node
   ...
   ...
   ...
   // Leaf Node
```

- **포인터 이동 개념**
	- `find(35)` 
		- Root Node `30 <= 35 <= 50` 이기 때문에 **2번째 포인터로 이동** 
	- `find(25)` 
		- Root Node `25 <= 30` 이기 때문에 **1번째 포인터로 이동** 
	- `find(55)` 
		- Root Node `50 <= 55` 이기 때문에 **3번째 포인터로 이동** 

1. Root 노드 `[30 50]` 에서 `35` 는 `30` 보다 크고 `50` 보다 작으므로 **두번째 자식 노드`[30 40]`** 로 이동.
2. 노드 `[30 40]` 에서 `35` 는 `30 < 35 < 40` 이므로 **두번째 포인터를 따라 리프 노드로 이동** 
3. Leaf 노드에서 `35` 가 존재하는지 확인.
	- **있으면 포인터를 반환** 
	- **없으면 null 반환** 
- **만약 Leaf Node 전에 Search Key값을 찾았다면?** 
	- B+트리라면 Leaf Node까지 무조건 가야한다. (데이터는 Leaf Node에 있기 때문에)
	- 그래서 위와 똑같은 방식으로 Leaf Node까지 우선 이동함.

## B+- 트리 Range Query

- B+ 트리는 **검색 키(Search Key)의 특정 범위 `[lb, ub]`에 해당하는 모든 데이터를 찾는 데 매우 효율적**입니다.

### B+ 트리에서 findRange(lb, ub) 연산 수행

1. `lb(lower bound)` 값을 찾음
	- 일반적인 `find(lb)` 검색처럼 **루트(Root) 노드에서 시작**하여 `lb` 값이 속한 **리프(Leaf) 노드까지 이동**합니다.
	- 만약 `lb` 값이 리프 노드에 없다면, **lb보다 크면서 가장 가까운 값으로 이동**합니다.
2. 리프 노드에서 `lb ≤ Ki ≤ ub` 범위 내의 키를 수집
	- `lb` 이상인 첫 번째 값을 찾았으면, **해당 키와 연결된 데이터(레코드)를 결과 집합(ResultSet)에 추가**합니다.
	- 이후, 같은 리프 노드에서 **다음 키(Kᵢ)도 `ub` 이하인지 확인하면서 계속 추가**.
3. 다음 리프 노드로 이동하여 범위 내 키를 계속 수집
	- 현재 리프 노드의 마지막 키까지 탐색했으면, **다음 리프 노드로 이동**하여 같은 과정을 반복.
	- B+ 트리는 **리프 노드들이 Linked List(연결 리스트)로 연결되어 있어, 효율적으로 순차 검색 가능**.
	- 범위를 초과하는 키(`C.Kᵢ > ub`)를 만나거나, 더 이상 리프 노드가 없으면 탐색 종료.

```
              [30   50] // Root Node
             /       |       \
     [10  20]   [30  40]   [50  60] // Leaf Node
```

쿼리: `findRange(25, 55)` 수행

1. `25` 이상인 **첫 번째 키를 찾아 리프 노드 `[30 40]`으로 이동**.
2. `[30 40]`에서 `30`과 `40`이 범위 내이므로 **추출**.
3. **다음 리프 노드 `[50 60]`으로 이동**.
4. `[50 60]`에서 `50`은 범위 내이므로 **추출**, `60`은 초과하므로 **검색 종료**.

**결과:** `{30, 40, 50}`

- **검색시에 lb와 ub가 주어진다** 
- **탐색 종료 케이스**
	- 검색 범위를 초과하는 키를 만나면 좋료.(ub보다 큰 케이스)
	- 더이상 leaf node가 없는 경우 종료

## Query Cost

### B+ 트리에서 쿼리 수행 과정

B+ 트리에서 특정 값을 찾는 과정은 다음과 같습니다:

1. **루트(Root)에서 시작하여 리프(Leaf) 노드까지 탐색**
    - 내부 노드를 따라 **로그(log) 시간 내에 리프 노드에 도달**.
    - 트리의 높이가 `⌈log_{n/2}(N)⌉`이므로, **O(log N) 시간 복잡도를 가짐**.
2. **리프 노드에서 해당 값을 검색 및 반환**
    - 특정 키를 찾으면 해당 레코드의 **포인터(pointer)를 반환**.
    - Range Query인 경우, 연속된 리프 노드에서 여러 값을 읽어야 함.

### B+ 트리의 노드 크기와 성능 최적화

- **노드 크기 = 디스크 블록 크기**
    - 보통 4KB 크기로 설정됨.
    - 검색 키가 12바이트, 디스크 포인터가 8바이트라면 **n ≈ 200** (한 노드에 약 200개의 키 저장 가능).
- **트리의 높이 계산**
    - `N = 1,000,000`개의 데이터가 있을 때,
    - **B+ 트리의 높이:** `⌈log_50(1,000,000)⌉ = 4`
    - 즉, **4개의 노드만 읽으면 검색 완료**.
- **디스크 읽기 비용 최적화**
    - 노드 수가 4개이므로, **최대 4개의 블록만 디스크에서 읽으면 됨**.
    - 루트 노드는 자주 접근되므로 **버퍼 캐시에 저장될 가능성이 높음** → **보통 3개 이하의 블록만 읽으면 됨**.

### B+ 트리 vs. 이진 탐색 트리(Binary Tree)

| 비교 항목       | B+ 트리                 | 이진 탐색 트리 (BST)      |
|---------------|----------------------|----------------------|
| **노드 크기**   | 블록 크기 (4KB)       | 작은 노드 (2포인터)   |
| **높이**       | 작음 (fat & short)    | 큼 (tall & thin)     |
| **탐색 비용**   | ⌈log_{n/2}(N)⌉       | ⌈log_2(N)⌉          |
| **디스크 접근 비용** | 4 블록 읽기 (log_50(N)) | 20 블록 읽기 (log_2(N)) |

**즉, B+ 트리는 디스크 I/O 비용을 최소화하기 위해 "짧고 넓은(fat & short)" 트리 구조를 가짐.**
**이진 탐색 트리(BST)는 깊이가 깊어(`log_2(N)`) 더 많은 디스크 접근이 필요.**


### Range Query(범위 검색)의 추가 비용

1. **리프 노드에 도착한 후, 범위 내 포인터들을 모두 검색해야 함.**
    - 검색 범위 `[M / (n/2)] + 1` 개의 리프 노드 접근.
    - 리프 노드는 **연결 리스트(Linked List)로 연결되어 있어 순차 접근이 가능**.
2. **클러스터링(Clustered Index) 여부에 따른 성능 차이**
    - **Clustered Index**: 연속된 데이터 블록에 저장되므로 **디스크 I/O 비용이 적음**.
    - **Secondary Index**: 데이터가 분산되어 있어 **랜덤 I/O 비용이 증가할 수 있음**.

**즉, 범위 검색 시에도 B+ 트리는 연속된 리프 노드를 순차 접근 하므로 성능이 좋음.** 

### B+ 트리 쿼리 비용 최적화 결론

- **탐색 과정**
    - 트리 높이 `⌈log_{n/2}(N)⌉`을 따라 리프 노드 도달 → **O(log N)**
    - **디스크 접근 횟수 최소화 (4개 이하의 블록 읽기 가능).**
- **Range Query (범위 검색) 비용**
    - 리프 노드에서 `M / (n/2) + 1` 개의 블록 접근.
    - **연결 리스트 구조 덕분에 순차 검색이 가능하여 I/O 비용 절감**.
- **B+ 트리는 이진 탐색 트리보다 디스크 I/O 비용이 훨씬 적음**
    - 이진 탐색 트리: 약 `20`개의 노드 접근 (`log_2(N)`)
    - B+ 트리: `4`개의 노드 접근 (`log_50(N)`)


# B+- 트리 갱신

- **B+- 트리에서 업데이트 특징**
	- **B+ 트리는 항상 균형을 유지해야 한다.**
	- **검색 키(Search Key)를 정렬된 상태로 유지해야 한다.** 
	- **노드가 너무 커지거나 작아지면 "분할(Split)" 또는 "병합(Coalesce)"이 필요할 수 있다.** 
- B+ 트리 Update 복잡도
	- 데이터베이스에서 B+트리를 왜 쓸까?
		- **I/O 연산의 관점에서 삽입과 삭제 연산의 비용은 B+트리 높이에 비례하므로 작다** 
		- **데이터베이스 구현에서 인덱스 구조로 종종 B+트리를 사용하는 이유는 I/O 연산 속도 떄문이다** 

## 삽입

1. **검색(Find) 과정**

- 기존의 `find(v)` 함수처럼, **루트에서 리프 노드까지 이동**하여 새로운 값을 삽입할 위치를 찾음.

2. **삽입(Insert)**

- 리프 노드에 새로운 `(키, 포인터)`를 추가.
- **정렬을 유지하면서 삽입** (오름차순 유지).

3. **리프 노드가 꽉 찼다면? → 분할(Split) 필요**

- 리프 노드가 **최대 용량**을 초과하면 **절반으로 분할(Split)**.
- 중앙값을 부모 노드로 올려서 부모 노드에 새로운 키를 삽입.
- 부모 노드도 꽉 찼다면? → **재귀적으로 분할을 반복**.

**결과:**

- 삽입이 끝난 후에도 **모든 노드의 키 값이 정렬된 상태로 유지됨**.
- **트리의 균형이 유지되도록 필요하면 노드를 분할(Split)**.

### Leaf Node 삽입 예제

> **예제 "Adams"를 삽입하는 과정**

**[이미지] instructor 파일의 B+-트리 (n = 4)**

![](/assets/database-system09.png)

- 일반적인 삽입 과정

1. 먼저 삽입 할 위치를 찾는다.
	- `find()` 알고리즘을 통해서 루트노드에서 리프노드까지 이동하여 새로운 값을 삽입 할 위치를 찾는다.
2. 리프 노드에 값을 추가
	- 리프 노드에서 **적절한 위치에 새로운 키를 삽입** 하여 정렬 상태 유지한다.
3. 리프 노드에 공간이 충분하면 그대로 저장하고 종료한다.
	- 삽입 완료

- Split 필요한 CASE ("Adams" 삽입 예시)

1. `find()` 로 "Adams" 삽입 위치를 찾는데 알파벳 순이 Key값순이니까 leaf node의 제일 첫번째 노드에서 가장 맨 앞에 삽입 되어야 한다.
	- EX) 위의 그림에서 `Adams, Brandt, Califieri, Crick` 이렇게 맨 앞에 삽입 되어야 하는데 노드가 꽉 찬 상황이다.
		- **리프 노드 Split해야 한다** 
2. 기존 노드를 둘로 나눔
	- 첫 번째 리프 노드: `["Adams", "Brandt"]`
	- 두 번째 리프 노드: `["Califieri", "Crick"]`
3. **새로운 노드의 첫 번째 키 `"Califieri"`를 부모 노드에 삽입**.
	- (즉, 새로운 노드를 트리에 반영하기 위해 부모 노드도 업데이트됨)

**결과적으로, 트리의 높이는 그대로 유지되지만, 새로운 노드가 추가됨.**

- 부모 노드도 가득 찬 CASE (부모 노드도 Split)
	- 부모 노드도 공간이 부족하면 **재귀적으로 부모 노드도 분할(Split)해야 합니다.**
		- 분할된 노드의 **가장 작은 키 값**을 부모 노드로 올림.
		- 부모 노드도 꽉 차면 **최상위까지 올라가며 Split을 반복**.
		- **루트 노드까지 Split이 발생하면 트리의 높이가 증가함**.

**Adams 삽입 결과**

![[Pasted image 20250314230556.png]]

![[Pasted image 20250314230626.png]]

### Internal node 삽입 예제

- Internal node 에서 Split이 왜 발생할까?
	- B+ 트리는 항상 정렬 상태를 유지해야 하며, 모든 리프 노드는 동일한 깊이를 가져야 한다.
	- 리프 노드에서 Split이 발생하면, **부모(Internal) 노드에 새로운 키가 추가됨.**
	- 부모(Internal) 노드도 꽉 차면 다시 Split이 발생할 수 있음.
	- 최악의 경우 **루트까지 Split이 발생하여 트리의 높이가 증가할 수도 있음.**

> **예제 "Lamport"를 삽입하는 과정**

**이미지 이전 결과** 

![[Pasted image 20250314230626.png]]

1. **1단계: 리프 노드에서 "Lamport" 삽입**

- 삽입 할 위치를 찾기 위해서 `find()` 실행 리프 노드까지 이동.
- 리프 노드에서 `Lamport` 삽입 위치에 `[ Gold, Katz, Kim ]` 로 가득 차 있다.
- 리프 노드를 **Split** 해야한다.
- **Split 결과** 
	- 첫 번째 리프 노드 → `["Gold", "Katz"]`
	- 두 번째 리프 노드 → `["Kim", "Lamport"]`
- **핵심 새로운 노드의 첫 번째 키 `"Kim"`을 부모(Internal) 노드에 올려야 함.** 
	- (부모 노드가 새로운 자식을 인식할 수 있도록 해야 함)
	- 부모 노드인 Internal node도 가득 차있어 Split 해야 한다.

2. **2단계: Internal Node(부모 노드) 업데이트**

```ts
// 1단계 leaf node split
			 Mozart 
	Califieri, Einstein, Gold |
	Gold, Katz | Kim, Lamport // leaf node Split

// 2단계 internal node split
			 Mozart 
	Califieri, Einstein | Gold, Kim // Gold가 가장 작은 키니까 부모에게 전달
	Gold, Katz | Kim, Lamport

// 3단계 최종 결과 Root node에 Gold 삽입
			 Gold, Mozart 
	Califieri, Einstein | Kim // Gold가 가장 작은 키니까 부모에게 전달
	Gold, Katz | Kim, Lamport
```

- `Kim` 을 부모노드에 추가 하려고 하니 공간 부족.
	- **부모 노드에서도 Split 발생** 
- **Gold** 가 가장 작은 키로 부모노드인 `Root Node` 에 삽입됩니다.

**즉, B+ 트리는 항상 균형을 유지하기 위해 삽입 시 Split을 통해 자동으로 구조를 조정하는 트리!** 

**이미지 결과**

![[Pasted image 20250314234555.png]]


## 삭제

1. **검색(Find) 과정**

- `find(v)` 함수처럼, **삭제할 값을 포함하는 리프 노드를 찾음**.

2. **삭제(Delete)**

- 리프 노드에서 해당 `(키, 포인터)`를 제거.
- **왼쪽으로 값을 당겨서 정렬 유지**.

3. **노드가 너무 작아졌다면? → 병합(Merge) 또는 재분배(Redistribution)**

- 리프 노드가 **최소 개수 미만(n/2 이하)으로 줄어들면**, **형제 노드와 병합(Merge) 또는 값을 재분배**.
- 병합하면 부모 노드에서도 키를 삭제해야 하므로, **부모 노드에서도 최소 개수 미만이면 재귀적으로 병합 진행**.

 **결과:**

- 삭제 후에도 **정렬 상태 유지**.
- **균형을 유지하기 위해 필요하면 병합(Coalesce) 또는 재분배 수행**.

### 삭제 과정 개요

B+ 트리에서 노드를 삭제하면, 노드의 데이터가 너무 적어져서 underflow(최소 개수 미만) 상태가 될 수 있습니다. 이 경우, 노드를 병합(merge)하거나, 형제 노드에서 키를 가져오는 재분배(redistribution)를 수행해야 합니다.

> **예제 "Srinivasan"을 삭제하는 과정** 

**이미지 Srinivasan 삭제전** 

![[Pasted image 20250314230626.png]]

1. "Srinivasan"을 삭제하기 위해 리프 노드를 찾는다
	- Leaf node에서 "Srinivasan" 를 삭제하면 해당 노드에는 **Wu** 만 남게 된다.
	- **여기서 n=4이니까 1 < (n -1) /2 (각 노드가 적어도 반은 채워지는것을 보장)**  이기 때문에 해당 노드는 다른 형제 노드와 **Merge(병합) 되거나 노드들 간의 엔트리가 Redistribution(재분배)된다** 
2. Merge를 선택 했을때 `Mozart, Singh, Wu` 노드로 병합하고 해당 노드를 삭제하고 이때 부모 노드에 있는 "Srinivasan"도 삭제하고 가리키고 있는 포인터도 삭제한다.
	- **이때 부모 노드는 하나의 포인터만 가리키고 있을것이고 해당 노드는 Search Key값이 없을 것이다** 
	- 이를 위해서 형제 노드와 Merge를 하기 위해서 살펴보면 이미 가득 차 있기 때문에 불가능하고 Merge로 해결 할 수 없는 케이스인것을 알 수 있다.
3. redistribute(재분배)를 한다.
	- **internal node** 에서 재분배가 발생하고 있는 상황이다.
	- 최소 포인터를 2개를 가질 수 있게 왼쪽에 4개의 포인터중에 1개의 포인터를 재분배 해주면 된다.
	- Mozart옆의 노드 Gold의 노드에서 Gold가 가작 작은 Key값이므로 Gold를 제일 Root node로 올리고 Mozart를 internal node로 내리면 2개의 포인터가 생긴다.

**이미지 Srinivasan 삭제 후** 

![[Pasted image 20250315032043.png]]

> **예제 "Singh" 와 "Wu" 을 삭제하는 과정** 

**이미지 Singh Wu 삭제 결과**

![[Pasted image 20250315031837.png]]

# B+- 트리 확장

- 인덱스 순차 파일 구조의 주요 단점
	- **파일이 커지면서 성능이 감소하는 것이다** 
	- 파일이 커지면서 인덱스 엔트리와 실제 레코드의 증가 비율이 맞지 않게 되면서 오버플로블록에 레코드를 저장하게 된다.

## B+트리 파일 구조

B+ tree file organization

- **파일에 B+트리 인덱스를 사용함으로써 인덱스 검색의 성능 저하를 해결한다** 
- 실제 레코드를 포함하는 블록을 구성하기 위해 B+트리의 Leaf Node 단계를 사용함으로써 실제 레코드 저장에 대한 성능 저하 문제를 해결한다.
- 트리의 Leaf Node는 레코드에 대한 포인터를 저장하는 대신 레코드를 저장한다.
- B+트리 파일구조로부터 레코드의 삽입과 삭제는 **B+트리 인덱스의 삽입과 삭제**와 동일한 방법으로 수행된다.








# B- 트리

## 1. B-Tree와 B+Tree의 차이점

- B-Tree는 **search key 값이 내부 노드와 리프 노드 모두에 존재**할 수 있음.
- B+Tree는 **search key 값이 리프 노드에만 존재**하며, 내부 노드는 검색을 위한 경로 역할을 함.
- 따라서, B-Tree는 **중복 저장을 최소화**할 수 있지만, B+Tree는 **리프 노드들이 정렬된 상태로 연결되어 범위 검색에 유리**함.

## 2. B-Tree의 특징

- 검색 키 값이 내부 노드에만 존재할 수도 있고, 리프 노드에도 존재할 수 있음.
- 중복 저장이 없는 대신, **추가적인 포인터 필드가 필요**함.
    - 검색 키가 내부 노드에 존재하는 경우, 해당 키와 연결된 데이터 레코드로의 포인터도 함께 저장해야 함.
- 인덱스를 **더 적은 노드 개수로 유지할 수 있음**, 즉, B+Tree보다 **메모리 절약 가능**.
- 하지만, 키가 내부 노드에 존재하고 리프 노드에 존재하지 않는 경우, 범위 검색 시 모든 서브트리를 탐색해야 할 수도 있음.

## 3. B-Tree의 탐색

- 탐색 키가 내부 노드에 존재하는 경우, 더 이상 리프 노드까지 가지 않아도 탐색이 완료될 수 있음.
- 반면, B+Tree는 항상 리프 노드까지 가야 하므로, 특정 값만 찾을 때는 B-Tree가 더 빠를 수 있음.
- 하지만 B-Tree는 **더 깊은 트리가 될 가능성이 있음**, 이는 검색 속도에 영향을 줄 수 있음.


## 4. B-Tree의 삽입과 삭제

- **삽입**:
    - 내부 노드에 삽입될 수도 있고, 리프 노드에 삽입될 수도 있음.
    - 필요할 경우 노드가 split(분할)되며, 부모 노드로 키 값이 올라갈 수 있음.
- **삭제**:
    - 삭제할 키가 내부 노드에 있을 경우, **서브트리에서 적절한 대체 키 값을 찾아 내부 노드를 채워야 함**.
    - 대체 키 값으로는 **해당 키보다 큰 값 중 가장 작은 값**을 선택함.
    - 만약 리프 노드에 키가 너무 적어지면 **형제 노드와 병합하거나, 키를 재분배**함.


# QA)

- **root 노드만 존재하는 경우?** 
	- 즉, root 노드가 leaf 노드인 경우
	- **root 노드는 2 ~ n개 사이의 자식을 갖는다.**
	- root 노드가 leaf 노드라면 (트리에 root 노드만 존재한다면) **0 ~ (n-1) 사이의 개수만큼 value를 가진다** 
- B+- 트리 업데이트시
	- **밸런스 트리(균형트리)를 어떻게 정렬 상태를 유지하는것인가?**
		- underfull 상태가 아닐 수 있게 계속 유지한다.
	- **Split은 어떻게 하는것인가?**
- B+- 트리 삽입시에 Split 발생시 루트노드가 가득찬 경우는 어떻게 될까?
	- Root노드가 Split되고 새로운 루트 노드를 생성 합니다.
- B+-트리 삭제시 노드가 갖는 엔트리가 **underfull(미달)** 상태일때 Merge(병합)되거나 Redistribution(재분배)되는 기준이 뭘까?
	- 재분배
		- **인접한 노드와 Merge가 불가능 할때**
- B+ 트리에서 Underful(미달) 상태가 아닌 조건
	- **Search Key 값이 노드 크기의 절반 이상을 차지하는 경우**
	- **포인터(Pointer) 개수가 노드 크기의 절반 이상을 차지하는 경우**
	- Leaf 노드, internal 노드
		- n=4일때, 최대 포인터 개수 : 4, 최대 키 개수: 3, 최소 포인터 개수: `⌈4/2⌉ = 2` ,최소키 개수 `⌈(3)/2⌉ = 2` 
- B+ 트리에서 Underfull(미달) 상태를 유지해야하는 이유?
	- B+ 트리는 **Balanced** 구조를 유지하는 트리이기 때문에 각 노드가 최소한의 데이터(키 또는 포인터)를 유지 해야 합니다.
	- **왜?** 
		- 그렇지 않으면 탐색 및 성능이 저하 됩니다. 왜냐하면 이진트리도 아니기 때문에 한쪽에 너무 많은 포인터가 쏠리거나 한쪽에 너무 적은 포인터나 search key가 있다면
		- 한쪽으로만 계속 탐색하게 되어서 적은 search key나 포인터를 가지는 노드쪽의 성능이 저하 됩니다.
- 데이터베이스에서 B+트리를 왜 쓸까?
	- I/O 연산 비용을 최소화하기 위해서
		- 트리의 높이가 I/O 연산 속도에 비례한다.
		- B+ 트리에서 탐색 속도 자체가 log N으로 이진 탐색 방식으로 탐색하기 때문에 그런걸로 알고 있습니다. 근데 삽입과 삭제의 최악의 시간 복잡도는 `O(log[n/2](N))` 인데 여기서 n은 한 노드 안에 있는 포인터의 최대 개수이고 N은 인덱스된 파일에 있는 레코드의 개수입니다. 즉, 트리 깊이가 낮을수록 시간 복잡도가 낮다
- B+ 트리와 B-트리 차이
	- **범위 검색** 에서 B+트리 사용이 훨씬 유리하다.
	- B- 트리 같은 경우 특정 Search Key 탐색 같은 경우에 더 빠를 수 도 있다.
	- B- 트리는 Search Key가 중복되지 않아 메모리 효율이 더 높다.
	- B+ 트리는 결국 Leaf node에 모든 Search Key가 있고 모든 데이터 레코드는 leaf node에 있다.
	- B- 트리는 internel node에 Search Key가 있을 수 있고 즉, 모든 데이터 레코드가 internel node와 leaf node 둘다 있을 수 있다.
	- **B+ Tree는 Search Key가 leaf node에 순차적으로 정렬된 구조를 가진다. 링크드 리스트로 연결되어 있다** , **B- Tree는 Search Key가 internel node와 leaf node에 분산 되어 있다** 

