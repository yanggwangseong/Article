---
title: PART5 저장장치및 인덱싱
permalink: /cs/database/database-system-7th/PART5 저장장치및 인덱싱
tags:
  - Database
layout: page
---

# DiskBlockAccess

- 각 I/O요청은 디스크의 디스크 식별자와 논리 블록 번호로 구성된다.
- 디스크 블록에 대한 요청
	- 순차적 접근
	- 임의 접근

1. 버퍼링(Buffering)
	- 다음에 있을 요청을 충족하기 위해 디스크로부터 읽는 블록을 메모리 버퍼내에 임시로 저장하는 기법
2. Read-ahead (미리 읽기)
	- 디스크 블록에 접근할 때, 블록에 대한 요청이 없더라도 동일 트랙내의 연속적인 블록을 일단 메모리 내의 버퍼로 읽어 들이는 기법이다.
3. Scheduling (스케줄링)
	- FCFS(First-Come First-Served)
		- 디스크큐에 들어온 순서대로 요청을 처리
	- SSTF(Shortest Seek Time First)
		- 디스크큐에 들어온것중에서 현재 헤드의 위치에 가장 가까운 요청을 먼저 서비스 하는 기법
	- Scan
		- 처리 할 수 있는 접근 수를 최대한 증가시키는 방식으로 트랙 접근 순서를 정하려고 한다.
		- 엘리베이터 알고리즘
		- SSTF와 같은 방법으로 운영되지만 차이점은 **'진행 방향'** 상의 가장 짧은 거리에 있는 요청을 서비스하는 기법이다.
	- C-Scan
	- Look
4. File organization (파일 구성)
	- 블록 접근 시간을 줄이기 위해 데이터에 접근하고자 하는 방식에 가장 가까이 부합하는 방식으로 디스크의 블록을 조직할 수 있다.
5. Nonvolatile write buffer (NVRAM, 비휘발성 쓰기 버퍼)
	- 디스크 쓰기 속도를 높이기 위한 목적
	- 메인 메모리 같은 경우 휘발성 메모리이기 때문에 트랜잭션 처리 시스템 같은 갱신 중심 데이터베이스 응용 프로그램에서는 NVRAM을 통해서 이를 해결한다.

- HDD와 SSD 차이점
- HDD와 SSD의 Access 방식

# 디스크

- 저장 장치 계층
	- **속도와 비용의 트레이드오프**
	- cache
	- main memory
	- flash memory
	- magnetic disk
	- optical disk
	- magnetic tapes
- Magnetic Disk
	- **디스크 동작 방식**
	- 플레터
	- 트랙
	- 섹터
	- 암
	- read-write 헤더
	- 실린더
	- 스핀들
- Disk Performance 측정
	- access time (접근 시간)
	- seek time (탐색 시간)
	- sequential access (순차적 접근)
	- random access (랜덤 접근)
		- IOPS
	- MTTF(mean time to failure)
		- 평균적으로 시스템이 아무 실패 없이 계속해서 동작할 수 있는 시간이다.
- **Flash memory**
	- NOR Flash와 NAND Flash
	- SSD는 NAND Flash를 사용하여 만든다.
- **RAID**
	- 디스크의 성능과 신뢰성 향상을 위한 디스크 아키텍쳐
	- 중복에 의한 신뢰성 향상
	- 병렬화에 의한 성능 향상
- **Disk Block Access** 
	1. 버퍼링(Buffering)
		- 다음에 있을 요청을 충족하기 위해 디스크로부터 읽는 블록을 메모리 버퍼내에 임시로 저장하는 기법
	2. Read-ahead (미리 읽기)
		- 디스크 블록에 접근할 때, 블록에 대한 요청이 없더라도 동일 트랙내의 연속적인 블록을 일단 메모리 내의 버퍼로 읽어 들이는 기법이다.
	3. Scheduling (스케줄링)
		- FCFS(First-Come First-Served)
			- 디스크큐에 들어온 순서대로 요청을 처리
		- SSTF(Shortest Seek Time First)
			- 디스크큐에 들어온것중에서 현재 헤드의 위치에 가장 가까운 요청을 먼저 서비스 하는 기법
		- Scan
			- 처리 할 수 있는 접근 수를 최대한 증가시키는 방식으로 트랙 접근 순서를 정하려고 한다.
			- 엘리베이터 알고리즘
			- SSTF와 같은 방법으로 운영되지만 차이점은 **'진행 방향'** 상의 가장 짧은 거리에 있는 요청을 서비스하는 기법이다.
		- C-Scan
		- Look
	4. File organization (파일 구성)
		- 블록 접근 시간을 줄이기 위해 데이터에 접근하고자 하는 방식에 가장 가까이 부합하는 방식으로 디스크의 블록을 조직할 수 있다.
	5. Nonvolatile write buffer (NVRAM, 비휘발성 쓰기 버퍼)
		- 디스크 쓰기 속도를 높이기 위한 목적
		- 메인 메모리 같은 경우 휘발성 메모리이기 때문에 트랜잭션 처리 시스템 같은 갱신 중심 데이터베이스 응용 프로그램에서는 NVRAM을 통해서 이를 해결한다.


# 파일

- 파일이란?
- 블록이란?
	- **Disk를 논리적으로 나눈 단위**
- 페이지란?
	- **데이터베이스 시스템에서 Disk 블록을 관리하기 위해 사용하는 논리적인 단위** 
	- DBMS에서 디스크 블록을 추상화하여 페이지라는 단위를 사용하여 관리함으로써 확장성이 좋아졌다.
	- 왜 이렇게 사용하나?
		- DBMS와 OS가 독립적으로 데이터를 접근하게 만들어서 각기 다른 DBMS마다 페이지를 정의 할 수 있습니다.
		- 이를 통해서 여러가지 File 레코드를 구성 할 수 있게 됩니다.
- 레코드란?
- Fixed-Length Records (고정 길이 레코드) ✅
	- 각 레코드가 동일한 크기를 가진다. 고정된 크기의 필드들로만 구성한다.
	- 예를 들어 레코드 길이가 53바이트이면 첫번째 레코드부터 N번째 레코드까지 다 53바이트를 차지한다.
	- 문제점
		- 문제점1) 블록 크기가 53의 배수가 되지 않는다면 몇몇 레코드는 블록 경계를 넘게된다.
			- 즉, 하나의 레코드가 하나의 블록에 저장되지 않게되어 해당 레코드를 읽을때 두개의 블록에 모두 접근 해야 한다.
			- 해결방법)
				- 한 블록에 완전히 채울 수 있는 만큼의 블록만 레코드를 할당한다.
					- 어떻게?
						- 블록 크기를 레코드 크기로 나눠서 계산하여, 소수 부분은 무시하면 된다.
							- 예시) 블록 크기/ 레코드 크기 했을때 몫만큼만 블록에 할당하면 되는것 같다. 나머지가 발생하면 그건 다음 블록의 첫번째 레코드가 되는것 같다.
		- 문제점2) **레코드를 삭제하기가 어렵다** 
			- 해결방법1) 삭제할 레코드가 차지하는 공간은 그 파일의 다른 레코드로 채우는 방법을 사용
				- 한 레코드를 삭제할 때 이 레코드 뒤에 있는 모든 레코드를 바로 전 레코드가 차지한 공간으로 이동시킨다.
					- 단점) 많은 수의 레코드가 이동해야 한다.
				- 삭제한 레코드가 있었던 공간에 파일의 마지막 레코드를 이동하는게 쉬울 수 도 있다.
				- **레코드 이동은 추가적인 블록접근이 필요해서 바람직하지 않다** 
			- 해결방법2) 그 공간을 무시할 수 있도록 레코드를 삭제 했다는 표시를 해야한다.
				- **삽입할 레코드가 있을경우 이용 가능 공간을 찾기가 어렵다** 
	- **고정 길이 레코드 문제점 해결을 위한 추가적인 구조** 
		- 파일 앞부분에 일부 바이트를 할당해 **file header(파일 헤더)** 를 만든다.
		- 파일 헤더 정보
			- **내용이 삭제된 첫번째 레코드의 주소** 
			- **해당 첫번째 레코드의 주소를 사용해서 이용가능한 다음 레코드의 주소를 저장한다** 
			- 레코드 주소는 레코드의 위치를 가리키므로 해당 주소를 **포인터** 로 생각할 수 있다.
			- 연결 리스트를 형성
			- **만약 삽입시에 헤더를 통해서 이용가능 공간을 찾는데 없을경우 파일 끝에 새로은 레코드를 추가한다** 
- Variable-Length Records
	- 가변 길이 레코드가 필요한 상황
		- 문자열과 같은 가변 길이 필드가 있을 때
		- 배열 혹은 multiset과 같은 반복적인 필드를 포함하는 레코드 유형과 파일 내에 여러 유형의 존재가 있을경우
	- 여러 기법에서 해결 해야 하는 문제 2가지
		- 속성이 가변 길이인 경우에도 개별 속성을 쉽게 추출할 수 있는 방식으로 하나의 레코드를 표현하는 방법
		- 블록 내의 레코드를 쉽게 추출할 수 있도록 블록 내에 가변 길이 레코드를 저장하는 방법
	- 기법
		- 레코드
			- 레코드 처음 부분에서 길이와 위치 표시
				- 레코드 처음부분에서 **offset과 length** 쌍으로 가변길이 Attribute들의 위치와 길이를 표시한다.
				- 이후 고정 길이 속성들의 값을 연속적으로 저장한다.
				- 그 이후 가변 길이의 속성들의 값을 저장한다.
			- Null bitmap 방식
				- 값이 Null인 속성에 1바이트만 차지하게 Null bitmap을 사용
		- 페이지
			- slotted-page structure
				- 블록의 시작에 헤더가 포함하는 정보
					- 헤더에 있는 레코드 엔트리의 수
					- 블록에서 빈 곳의 끝
					- 각 레코드의 위치와 크기를 포함하고 있는 엔트리 배열
	- InnoDB에서 가변길이 레코드를 어떻게 관리하나요?
		- InnoDB는 Slotted Page 구조를 사용해 레코드를 관리하며, 레코드마다 헤더를 두어 트랜잭션 정보, NULL 비트맵, 가변 길이 정보를 포함시킵니다. VARCHAR나 TEXT 같은 필드는 길이에 따라 페이지 내 또는 외부에 저장되고, 외부 저장 시 포인터만 남겨둡니다. 또한, 레코드 오프셋은 페이지 끝의 슬롯 디렉터리에 저장되어 효율적인 탐색이 가능합니다.
- **파일 레코드 구성 방법** ✅
	- **Heap file organization (힙 파일 구성)**
		- 순서와 상관없이 레코드를 파일 내의 아무 위치에나 저장하는 방식입니다.
		- **언제 만들고 싶은지? 언제 쓰면 좋을까?** 
			- 순서가 보장되지 않아도 되고 삽입/삭제가 잦은 상황에서 사용.
			- 로그 테이블 파일을 구성할때 사용하면 좋을것 같습니다.
				- 새로운 로그가 삽입되고 오래된 로그는 주기적으로 삭제를 하며 잦은 삽입과 삭제가 일어나기 때문이다.
		- 배열 형태의 메타데이터 파일로 저장되어 관리된다.
			- 배열의 인덱스 -> 블록 번호, 배열의 값 -> free-space map
		- 속도는 빠르지만 정렬 기반 탐색에는 부적절
		- 갱신
			- 삭제 후 빈곳에 저장하는게 좋은데 DBMS에서 파일의 모든 블록을 순차적으로 검색하지 않고도 빈곳이 있는 블록을 효율적으로 찾을 수 있어야 한다.
		- 데이터베이스 시스템 -> 블록을 추상화한 페이지 단위의 논리적인 단위를 통해서 힙 파일 생성 -> OS 파일 시스템이 데이터베이스 시스템이 만든 힙 파일을 Disk의 블록에 저장한다.
		- Free-Space Map이란?
			- 데이터베이스에서 빈곳이 있는 블록을 효율적으로 찾기 위한 자료구조
			- 빈곳을 어떻게 구할까?
				- Free space map값/각 블록에 최대 사용 가능한 비트값
				- 예를 들어 블록마다 3bit씩 사용한다고 가정하면 3bit로 표현할 수 있는 값은 2의 3승인 8개의 값만 가능하다.
					- free-space map값 / 8을 한 값이 남은 공간으로 표현 할 수 있다.
		- 2단계 free-space map이란?
			- free-space map이 너무 커질경우 매우 느려지기 때문에 예를 들어 100개단위로 나누어서 해당 100개의 그룹의 최대 free-space값을 저장하는 2단계 free-space map을 만든다.
			- 만약 4개가 있다면 free-space map은 총 400개가 있는것이고 여유 있는 공간을 찾기 위한 탐색 시간을 1/100으로 소요된다.
	- **Sequential file organization (순차 파일 구성)**
		- Search Key 기준으로 데이터를 정렬하여 저장하는 파일 구조
		- 레코드가 정렬된 상태에서 검색이 자주 발생하는 경우 사용
		- 물리적으로 **검색 키 값 순서대로 저장되며, 레코드들은 포인터로 연결될 수 있음** 
		- 삭제
			- 포인터 체인 방식으로 삭제를 관리한다.
		- 삽입
			- Search Key 순서로 볼때 삽입할 레코드 바로 앞에 위치하는 레코드를 파일에서 찾는다.
			- 찾은 레코드와 같은 블록 내에 빈 레코드(즉 삭제한 후 빈 공간)가 있다면 거기에 새로운 레코드를 삽입한다.
			- 없는경우 **overflow block** 에 새로운 레코드를 삽입한다. 레코드를 Search Key 순서로 연결하기 위해 포인터를 조정한다.
		- 잦은 반복이 되게 되면 overflow block에 레코드가 계속 삽입되면서 포인터만 조정하는 방식이 된다면 실제 물리적으로 저장하는 물리적 순서와 Search Key순서가 달라지게 된다.
		- 이를 해결하기 위해서 다시 물리적으로 순차적인 순서가 되도록 파일을 **reorganized(재구성)** 해야한다.
		- **순차 파일 구조는 삽입/삭제가 적고 정렬된 접근만 필요한 정적 데이터에 사용** 
		- **언제 만들고 싶은지? 언제 쓰면 좋을까?** 
			- 데이터가 정적인 순서가 정렬되고 삽입/삭제가 거의 발생하지 않고 조회와 Range Query만 발생하는 대한민국 도시 테이블을 저장할때 사용 할것 같습니다.
	- **Multitable Clustering file organization(다중 테이블 군집 파일 구성)** 
		- **여러 다른 릴레이션의 레코드가 같은 파일에 저장하는 구성** 
		- cluster key라는 함께 저장되는 레코드를 정의하는 속성을 통해서 저장한다.
		- 조인은 빠르나 개별 쿼리는 느려질 수 있다.
			- 왜?
				- 릴레이션마다 파일에 저장 했을때 튜플의 개수가 적은 테이블을 조회 할 때 3번만 조회할것을 조인되어 저장된 파일 튜플을 전부 조회 해야(100번) 되는 경우
	- B+-트리 파일 구성 (B+- tree file organization)
	- 해싱 파일 구성 (Hashing file organization)
- Data-Dictionary Storage ✅
	- **system catalog** 라고도 한다.
	- Query가 실행되기 전에, 필요한 테이블/인덱스/컬럼 등의 **메타데이터 정보** 를 저장하는 스토리지
	- 시스템 메타데이터에 자주 접근 하기 때문에 인메모리 데이터 구조에 올려둔다.
		- 인메모리 데이터 구조란?
			- 데이터 베이스 시스템에서 사용하는 메인 메모리상의 논리적 캐시를 말합니다.
			- 종류)
				- **버퍼풀(데이터 페이지)** 
				- **Data-Dictionary Storage Cache (메타데이터)** 
				- 쿼리 캐시
			- 메인 메모리에서 사용하기 위해서 데이터베이스 시스템에서 구현한 **논리적인 캐시 데이터 구조** 
				- 예시) 하드웨어 캐시 CPU (L1, L2, L3 캐시), 소프트웨어 캐시(DBMS 버퍼풀, Data-Dictionary Storage Cache)
			- 소프트웨어 캐시라는것은 결국 특정한 자료구조(LRU캐시 등) 를 통해서 자주 사용하는것들을 메인 메모리에 저장하여 자주 사용하는 메타데이터를 접근 하는 방식을 말합니다.
	- 정보 정류
		- 릴레이션 이름
		- 각 릴레이션 속성의 이름
		- 속성의 도메인과 길이
		- 데이터베이스에 대해 정의한 뷰의 이름과 이 뷰에 대한 정의
		- 무결성 제약조건
		- 사용자 이름, 권한, 비밀번호 등
- **Database Buffer** ✅
	- 가상메모리 메커니즘 같은 느낌이다.
	- 메인 메모리에 크기가 큰 데이터베이스를 다 올릴 수 없는 문제가 있다.
	- **데이터베이스 시스템의 주요 목적은 디스크와 메모리 사이에 블록의 전송 수를 최소화하는 것** 
	- **Buffer란?** 
		- **디스크 블록의 복사본을 저장하기 위해 이용할 수 있는 메인 메모리의 일부분이다.**
		- 메인 메모리에서 **일부분을 차지하는 공간** 이고 임시 저장소다.
	- 데이터 베이스시스템에서 복사본 다루는 방법
		- 하드웨어
			- RAID 아키텍쳐
		- 소프트웨어
			- 메인 메모리 Buffer
	- **Buffer manager란?**
		- 버퍼 공간의 할당을 책임지고 있는 시스템
		- 데이터베이스 시스템 내의 프로그램은 디스크로부터 블록을 가져올 필요가 있을 때 Buffer manager를 호출한다.
		- 요청 블록이 버퍼에 있는 경우
		- 요청 블록이 버퍼에 없는 경우
			- 버퍼에 블록을 저장하기 위한 공간을 할당하는데 이때 공간을 만들기 위해 메모리에 있는 블록을 디스크로 보내기도 한다. **(스와핑)** 
			- 보내진 블록은 디스크에 쓰인 가장 최근것과 비교해서 변경된 것이 있으면 다시 디스크에 덮어쓰기 한다.
			- 버퍼 관리자는 디스크로부터 요구된 블록을 버퍼에 읽어 와서 메인 메모리의 블록 주소를 블록을 요청한 해당 프로세스에 전달한다
	- **버퍼에 고정된 핀 블록**
		- concurrent process를 방지하기 위해서 프로세스가 버퍼 블록으로부터 데이터를 읽기 전에 블록을 쫒아내지 않는 것이 중요하다.
		- 프로세스는 블록을 고정시키는 **pin(핀)** 연산을 실행한다.
			- 버퍼 관리자는 핀 블록을 제거하지 못한다.
		- **데이터 읽기가 끝나면 프로세스는 고정을 해제하는 unpin(언핀)연산을 실행** 하여 필요할 때 블록을 제거할 수 있도록 한다.
		- 여러 프로세스가 **pin** 연산과 **unpin** 연산을 수행 하는 경우 각 버퍼 블록의 **pin count** 를 계산하고 유지하는 방법을 사용한다.
			- pin연산시 카운트를 증가시키고 unpin연산시 카운트를 감소시킨다.
			- **버퍼 페이지는 핀수가 0인 경우에만 제거될 수 있다** 
	- **버퍼 Shared Locks과 Exclusive Locks**
		- **페이지에서 추가하거나 삭제하는 프로세스는 페이지 내용을 이동할 필요가 있다**
		- 이때 다른 프로세스도 페이지의 내용을 읽으면 안된다.
		- Lock을 위한 규칙
			- (TODO)
	- 버퍼 블록의 출력과 강제 출력
		- Buffer Block output이란?
			- 버퍼 공간이 필요한 경우 Replacement Strategy를 통해서 핀 되어 있지 않은 블록을 제거하는것을 말한다.
		- Buffer Block forced output이란?
			- 데이터를 일관성 있게 하기 위해서 동시성 제어 시스템으로 부터 트랜잭션이 commit 되는 경우
	- **버퍼 Replacement Strategy (18장,19장 언급)**
		- **목적** 
			- 디스크 접근을 최소화하기 위해서이다.
		- LRU(least recently used, 가장 오래전에 사용된 페이지를 제거)
			- 다음에 참조 할 블록
		- MRU(most recently used, 가장 최근에 사용된 페이지를 제거)
			- 재참조 할 마지막 블록
			- **마지막 튜플을 처리한 후 핀블록을 unpin한 블록이 최근에 가장 많이 사용한 블록** 
				- 예시) 마지막 튜플을 처리하고 나면 다시 마지막 튜플에 접근하지 않을 확률이 더 높기 때문에 가장 최근에 사용된 버퍼 페이지를 replacement 한다.
				- Join 구문을 생각 해보았을때 버퍼 페이지에 A와 B를 조인 한다고 했을때 B의 마지막 튜플이 처리되고 나면 그다음 참조될 가능성이 높은 페이지는 다시 재참조될 B의 첫번째 튜플이다.
				- 그러므로 LRU방식으로 교체하게 되면 Disk I/O가 발생한다.
		- 실제 블록 교체를 위한 최적의 전략은 **MRU(most recently used)** 방식이다.
			- **가장 최근에 참조를 어떻게 알 수 있나?** 
				- pin연산과 unpin연산
		- 교체되지 않아야 하는 정보
			- Data-Dictionary 메타데이터 정보
			- 데이터 파일에 대한 인덱스
		- 블록 교체 전략의 다른 요인
			- **언젠가 그 블록을 다시 참조하리라는 것보다 다른 요인에 의해 더 영향을 받는다** 
			- (CH18) 동시성 제어 시스템이 동시에 여러 사용자의 요청을 처리하고 있다면 데이터베이스의 일관성을 유지하기 위해서 어떤 요청은 미뤄질 수 있다.
				- 동시성 제어 시스템으로부터 어느 요청이 지연되고 있다는 것을 가리키는 정보를 버퍼 관리자에게 주면, 이 정보를 이용해서 버퍼 관리자는 블록 교체 방법을 변경할 수 있다.
			- (CH19) 충돌 복구 서브시스템은 블록 교체에 엄격한 제약 조건을 부과한다.
				- 어떤 블록을 변경했을 때 버퍼 관리자는 버퍼에 있는 블록의 최신 버전을 디스크에 다시 써서는 안된다.
- **column-oriented storage**
	- 각 속성(field)을 별도의 파일에 저장한다.
	- **많은수의 튜플에서 특정 속성에만 접근하는 데이터 분석 쿼리에 매우 적합하다** 
	- 이유
		- 감소한 I/O : 필요한 속성만 읽어와서 I/O가 감소한다.
		- CPU 캐시 성능이 향상
		- 압축이 효율적이다
		- 벡터 처리
	- 단점
		- 튜플 재구성 비용
		- 튜플 삭제 및 갱신 비용
		- 압축 해제 비용
	- **OLAP(Online Analytical Processing)에 사용** 
		- 대량의 데이터를 신속하게 분석하고, 복잡한 쿼리를 실행하는 기술
	- ORC와 Parquet
		- 열기반 파일 형식
	- ORC는 행지향 형식을 열지향 형식으로 변환한다.
		- 튜플 순차는 **stripe(스트라이프)** 라고 하는 열 기반 표현으로 나뉜다.
		- ORC 파일에는 여러개의 스트라이프가 존재하며, 각 스트라이프의 크기는 250메가바이트정도이다.
	- 사용예시) Google BigQuery, data-warehousing
- **main-memory database**
	- 모든 데이터가 메모리에 상주하는 데이터베이스다.
	- **Buffer manager가 없다** 




# 인덱스

- Ordered index
- **Hash index**
- Clustering index
- NonClustering index
- Dense index
- Sparse index
- Index update
	- Insertion
		- Dense index case
		- Sparse index case
	- deletion
		- Dense index case
		- Sparse index case
- B+트리 인덱스
	- Root Node
	- Leaf Node
	- NonLeaf Node
- BST vs B+트리 사용하는 이유
	- BST는 Balanced인 경우와 달리 Non-Balanced인 경우 탐색 속도가 O(n)으로 이진 탐색의 장점을 효율적으로 사용 할 수 없다.

## B+트리 파일

## 해시 인덱스

