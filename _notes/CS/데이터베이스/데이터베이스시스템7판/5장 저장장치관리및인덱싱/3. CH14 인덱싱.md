---
title: 인덱싱
permalink: /cs/database/database-system-7th/ch-14
tags:
  - Database
layout: page
---

# 기본 개념

- 데이터베이스 시스템의 **index(인덱스)** 는 도서관에서 사용되는 책의 인덱스와 똑같은 역할을 한다.
- 인덱스는 **효율적인 질의 처리** 를 위한 중요 요소이다.
- 만약 인덱스가 없다면 모든 질의는 사용하는 모든 릴레이션의 전체 내용을 읽어야 한다.

## 인덱스 종류

- **Ordered index** (순서 인덱스)
	- 값에 대한 **정렬** 된 순서로 되어 있다.
- **Hash index** (해시 인덱스)
	- bucket(버킷)의 범위 안에서 값이 일정하게 **분배** 되어 있다.
	- 값이 할당되는 버킷은 **해시 함수** 에 의해 결정된다.

## 순서 인덱스 기술의 평가 요소

- Access type(접근 유형)
	- 효율적으로 지원되는 접근 유형
	- 특정한 속성의 값을 가진 레코드나 특정한 범위에 들어가는 속성의 값을 가지는 레코드를 찾는것을 포함한다.
- Access time (접근 시간)
	- 특정한 데이터 항목이나 항목의 집합을 찾는 데 걸리는 시간
- Insertion time (삽입 시간)
	- 새로운 데이터 항목을 삽입하는데 걸리는 시간
	- 삽입 위치를 찾는데 걸리는 시간 + 인덱스 구조를 갱신하는데 걸리는 시간
- Deletion time (삭제 시간)
	- 데이터 항목을 삭제하는데 걸리는 시간
	- 삭제될 항목을 찾는데 걸리는 시간 + 인덱스 구조를 갱신하는데 걸리는 시간
- Space overhead (공간 부담)
	- 인덱스 구조가 사용하는 부가적인 공간


## Search key (검색키)

- 한 파일에서 레코드를 찾는데 사용되는 속성이나 속성들의 집합
	- 한 파일에 대해 여러 개의 인덱스가 있다면, 검색 키도 여러개 있다고 생각할 수 있다.

# 인덱스 레코드의 구성

- **index record(인덱스 레코드)** , 즉 **index entry(인덱스 엔트리)** 구성
	- **검색 키 값** 
	- **포인터** 
		- 이것을 검색 키 값으로 가지는 한 개 이상의 레코드에 대한 포인터
		- 디스크 블록의 식별자 + 블록 안에서 레코드를 구별하기 위한 **offset(오프셋)** 

![](/assets/index-record.png)

# 순서 인덱스

- **인덱스 구조 활용**
	- 파일 안에 있는 레코드에 대한 **random access(임의 접근)** 을 빨리 하기 위해서 **인덱스 구조를 이용**할 수 있다.
- **Ordered index (순서 인덱스)란?** 
	- **검색 키의 값을 정렬된 순서로 저장** 하고, 검색 키와 검색 키를 포함하는 레코드를 연계시킨다.

## Clustering index (클러스터링 인덱스)

- 레코드를 포함하는 파일이 연속적인 순서로 저장되어 있다면, 클러스터링 인덱스는 **그 파일을 연속적인 순서로 정의한 속성을 검색 키로 사용** 하는 인덱스를 말한다.

- 클러스터링 인덱스는 primary index(기본 인덱스)라고도 부른다.
- 클러스터링 인덱스의 검색 키는 주 키인 경우가 많지만 반드시 그럴 필요는 없다.


## NonClustering index (논클러스터링 인덱스)

- **파일의 연속적인 순서와 다른 순서** 로 구성되는 검색 키의 인덱스를 말한다.
- secondary index(보조 인덱스)라고도 부른다.


## Indexed-Sequential File (Indexed-Sequential File)

- **모든 파일은 어떤 검색 키에 의한 연속적인 순서로 정렬되어 있다** 고 가정 했을 때 검색 키에 대해 기본 인덱스를 가지는 파일을 **인덱스 순차 파일** 이라고 한다.


## 순서 인덱스 2가지 유형

- Dense index (밀집 인덱스)
- Sparse index (희소 인덱스)

### Dense index (밀집 인덱스)

- 인덱스 엔트리는 파일에 있는 모든 search key값에 대해 나타난다.
- **Dense Clustering index(밀집 클러스터링 인덱스)** 
	- 인덱스 레코드는 검색 키 값과 **그 검색 키 값의 첫번째 데이터에 대한 포인터** 를 포함한다.
		- *(똑같은 검색 키 값을 가진 나머지 레코드는 첫번째 레코드 이후부터 연속적으로 저장되기 떄문)* 
- **Dense Non-Clustering index(밀집 비클러스터링 인덱스)** 
	- 똑같은 검색 키를 가진 모든 레코드에 대한 포인터 목록을 저장해야 한다.

**밀집 인덱스 그림**

![](/assets/database-system02.png)

**검색 키 dept_name의 밀집 인덱스 그림**

![](/assets/database-system03.png)

### Sparse index (희소 인덱스)

- 인덱스 엔트리는 검색 키 값에 대해 **단지 몇개만** 나타난다.
- 희소 인덱스는 오직 릴레이션이 검색 키로 정렬되어 저장될 때 (= 인덱스가 **클러스터링 인덱스** 인 경우) 사용될 수 있다.
- 검색 키 값과 **그 검색 키 값의 첫번째 데이터 레코드에 대한 포인터** 를 포함한다.
- 레코드를 위치시키기 위해서는
	1. **찾고자 하는 검색 키보다 작거나 동일한 것 중 가장 큰 검색 키** 를 가지는 인덱스 엔트리를 찾는다.
	2. 그 검색 키 엔트리에 의해 가리켜지는 레코드를 시작으로, 그 파일에서 원하는 레코드를 찾을 때까지 포인터를 따라간다.

![](/assets/database-system04.png)


### 밀집 인덱스 vs 희소 인덱스

- 일반적으로 레코드의 위치를 정하기 위해서는 희소 인덱스보다 `밀집 인덱스`를 사용하면 더 **빠르다**.
- 그러나 `희소 인덱스`는 밀집 인덱스보다 **더 적은 공간을 요구해서** 삽입과 삭제에 대한 유지 부담이 더 적다.
- 좋은 절충안은 **블록당 하나의 인덱스 엔트리를 가지는** `희소 인덱스`를 가지는 것이다.
	- **데이터베이스 요구를 처리하는 데 드는 비용 중 지배적인 것은 디스크에서 메인 메모리로 블록을 가져오는 데 걸리는 시간**이기 때문에, 일단 블록을 가져왔으면 전체 블록을 훑어보는 데 걸리는 시간은 대수롭지 않기 때문이다.


## 다계층 인덱스

- multilevel index (다계층 인덱스)
	- 두 개 혹은 그 이상의 단계를 가지는 인덱스

인덱스가 메인 메모리에 유지될 만큼 충분히 크기가 작다면 엔트리를 찾는 데 걸리는 검색 시간은 짧다.
하지만 전체 인덱스가 메모리에 유지될 수 없을 만큼 크다면 **필요할 때마다 인덱스 블록을 디스크로부터 가져와야** 하고, 그 다음에 인덱스에서 엔트리를 찾기 위해 여러 개의 디스크 블록을 읽어야 한다.

- **크기가 큰 인덱스에 대한 검색은 비용이 많이 발생한다** 

이 문제를 해결하기 위해서는 인덱스를 다른 순차 파일처럼 취급하여 **내부 인덱스** 라고 불리는 **원래의 기본 인덱스에 대한** **희소 외부 인덱스** 를 구성할 수 있다.

인덱스 엔트리는 외부 인덱스를 희소하게 분포 시키며, 항상 정렬된 순서로 존재한다.

### two-level Sparce index에서 레코드의 위치를 찾기 위한과정

![](/assets/database-system05.png)

![](/assets/database-system06.png)

1. 외부 인덱스상에서 이진 검색을 이용하여 원하는 레코드보다 작거나 같은 검색 키 값중에서 가장 큰 값을 가지는 레코드를 찾는다.
	- **이 레코드 포인터는 내부 인덱스 블록을 가리킨다** 
2. 해당포인터가 가리키는 블록을 스캔하여 원하는 레코드보다 작거나 같은 검색 키 값중에서 가장 큰 값을 가지는 레코드를 찾는다.
	- **이 레코드에 있는 포인터는 찾고자 하는 레코드를 포함하는 파일의 블록을 가리킨다** 

## 인덱스 갱신

- 모든 인덱스는 어떤 레코드가 파일에 **삽입** 되거나 파일로부터 **삭제** 될때마다 갱신되어야 한다.
- 파일 안에 레코드가 **갱신** 된 경우에는 갱신에 영향을 받은 **Search Key** 를 소유한 어떤 인덱스도 갱신 되어야 한다.
	- 하지만 레코드의 갱신은 이전 레코드가 삭제되어 뒤이어 새로운 레코드의 값이 삽입되는 것으로 모델링되며, 인덱스도 삭제된 후 새로운 인덱스가 삽입되는 결과를 보인다.
	- 따라서 인덱스에 대한 삽입과 삭제에 대해서만 고려하며, 명시적으로 갱신을 고려하지 않아도 된다.

### Insertion (삽입)

1. 시스템은 삽입되는 레코드의 검색 키 값을 사용해서 **찾기를 수행한다** 
2. 그 다음 해야할 일은 인덱스의 종류(밀집, 희소)에 따라 다르다.

- **Dense index (밀집 인덱스)** 

```
데이터 파일
ID   Name
1    Alice
2    Bob
3    Charlie
4    David

Search Key → Pointer
1 → (Alice의 위치)
2 → (Bob의 위치)
3 → (Charlie의 위치)
4 → (David의 위치)
```

- (1) 검색 키 값이 인덱스에 없는 경우
	- 예를 들어 **ID = 5, Name = Eve**를 추가한다면?
	- **ID 5가 인덱스에 없으므로** 새로운 인덱스 엔트리를 추가해야 함.

```
// 새로운 Dense Index
Search Key → Pointer
1 → (Alice의 위치)
2 → (Bob의 위치)
3 → (Charlie의 위치)
4 → (David의 위치)
5 → (Eve의 위치)  👈 추가됨
```

- (2) 같은 검색 키 값이 이미 존재하는 경우
	- 예를 들어 **ID = 3, Name = Chloe**를 추가한다면?
	- **Dense Index가 "3"을 이미 포함하고 있으므로**, 새로운 레코드의 위치를 포인터 목록에 추가해야 함.

```
// 업데이트된 Dense Index
Search Key → Pointer
1 → (Alice의 위치)
2 → (Bob의 위치)
3 → [(Charlie의 위치), (Chloe의 위치)]  👈 중복된 Search Key에 대한 포인터 추가
4 → (David의 위치)
5 → (Eve의 위치)
```

- **Sparse index(희소 인덱스)**

- (1) 새로운 블록이 생성될 경우

```
블록 1: (1, 2)
블록 2: (3, 4)

// Sparse Index:
Search Key → Pointer
1 → (블록 1의 시작)
3 → (블록 2의 시작)
```

- 새로운 레코드 **ID = 5, Name = Eve**가 추가될 때, 새로운 블록이 필요하면?
	- 새로운 블록이 생기면서 **ID 5가 해당 블록의 첫 번째 검색 키 값이므로**, 인덱스에 추가됨.

```
블록 1: (1, 2)
블록 2: (3, 4)
블록 3: (5)  👈 새로운 블록 생성됨!

// 업데이트된 Sparse Index
Search Key → Pointer
1 → (블록 1의 시작)
3 → (블록 2의 시작)
5 → (블록 3의 시작)  👈 새로운 블록이 생성되었으므로 인덱스 갱신
```

- (2) 새로운 블록이 필요하지 않은 경우
	- 만약 **ID = 2.5, Name = Carl**이 삽입된다면?
	- 기존 블록에 추가되므로 Sparse Index는 변하지 않음.

### deletion (삭제)

1. 시스템은 먼저 삭제될 레코드를 찾는다.
2. 그 다음 해야할 일은 인덱스의 종류에 따라서 다르다.

- **Dense index (밀집 인덱스)** 

1. Case 1: 삭제할 레코드가 유일한 경우
2. Case 2: 같은 검색 키 값을 가지는 여러 레코드가 있을 경우
3. Case 3: 인덱스 엔트리가 첫 번째 레코드만 가리키는 경우

- **Sparse index(희소 인덱스)**
	- Case 1: 삭제된 레코드가 인덱스 엔트리에 포함되지 않은 경우
		- 만약 인덱스가 **삭제된 레코드의 검색 키 값을 가지는 인덱스 엔트리를 포함하고 있지 않다면** 인덱스에 대해 해야 할 일은 없다.
	- Case 2: 삭제된 레코드가 인덱스에 포함된 경우
		- 만약 **삭제된 레코드가 그 검색 키를 가지는 유일한 레코드였다면,** 시스템은 대응되는 인덱스 레코드로 교체한다.
		- **다음 검색 키 값이 이미 인덱스 엔트리에 있다면,** 이 엔트리는 교체되는 대신 삭제된다.
		- 그렇지 않다면 검색 키 값을 위한 인덱스 엔트리는 삭제된 레코드를 가리키고 있다는 것이다.
			- 시스템은 인덱스 레코드가 똑같은 검색 키 값을 가지는 다음 레코드를 가리키도록 갱신한다.

### multilevel index (다계층 인덱스) 갱신


**multilevel index (다계층 인덱스)를 위한 삽입과 삭제는 위의 구조를 간단히 확장 하기만 하면 된다** 

- 삭제나 삽입 시 시스템은 위에서 설명한 알고리즘대로 가장 낮은 단계의 인덱스를 갱신한다.
- 2 level index 입장에서 가장 낮은 단계의 인덱스는 단순히 레코드를 담고 있는 파일 뿐이다.
- 그래서 가장 낮은 단계의 인덱스에 어떤 변화가 있다면 시스템은 위에서 설명한 알고리즘대로 2 level index를 갱신한다.
- 더 많은 단계의 인덱스에 대해 동일한 방법을 적용하여 갱신할 수 있다.

## Secondary Index(NonClustering index) 보조 인덱스

![](/assets/database-system07.png)

**Clustering index** 는 단지 몇몇 개의 검색 키 값을 저장하는 **희소 인덱스**여도 된다.

- 보조 인덱스는 모든 검색 키 값과 모든 레코드에 대한 포인터를 가지는 인덱스 엔트리로 된 **밀집 인덱스** 여야 한다.
- 즉, 보조 인덱스는 **모든 레코드에 대한 포인터를 포함해야 한다** 
- 레코드는 **보조 인덱스의 검색 키에 의해서가 아닌, 기본 인덱스의 검색 키에 의해 순서대로 되어 있기 때문에** 똑같은 검색 키의 값을 가지는 나머지 레코드는 파일의 아무 곳에나 흩어져 있을 수 있다.

클러스터링 인덱스와 논클러스터링 인덱스

- 클러스터링 인덱스 순서에서 연속적으로 스캔 하는 것은 효율적이다.
	- (파일에 있는 레코드가 인덱스의 순서와 똑같은 순서로 물리적으로 저장되어 있기 때문에)
- 파일을 보조 키 순서대로 스캔을 시도한다면, 각 레코드를 읽는 것은 디스크로부터 새로운 블록 읽기를 요구하는것과 같기 때문에 매우 느리다.
- 논클러스터링 인덱스는 클러스터링 인덱스의 검색 키가 아닌 다른 키를 사용하는 질의문의 성능을 향상시키지만, 데이터베이스 변경에 상당한 부담을 강요한다.
- 따라서 **논클러스터링 인덱스는 검색만을 위한 질의와 데이터 변경의 상대적으로 빈도에 대한 평가에 기초해서 결졍되어야 한다** 

### nonunique search key (비고유 검색 키)

- nonunique search key란?
	- 릴레이션에 동일한 search key값을 가지는 레코드가 두 개 이상 존재한다면, 즉 **두개 이상의 레코드가 인덱싱 속성에 대해 동일한 값을 가질 수 있다면,** 이러한 검색 키를 **nonunique search key** 라고 한다.

비 고유 검색 키에 대해서 보조 인덱스를 구현하려면,
보조 인덱스에 있는 각각의 포인터는 **그 파일에 대한 포인터를 담고 있는 버킷을 가리켜야 한다** 

- **단점**
	- 임의 I/O 작업이 필요한 간접 참조로 인해 인덱스 접근 시 시간이 더 오래 걸린다.
	- 키에 중복이 거의 없거나 전혀 없는 경우, 전체 블록이 해당 버킷에 할당되면 많은 공간 낭비가 발생한다.


## 다중 키상의 인덱스

- 두 개 이상의 속성으로 구성된 검색 키를 **composite search key(복합 검색 키)** 라고 한다.
- 검색 키가 하나의 속성이 아니라, 속성의 목록으로 되어 있다.
- 검색 키는 **값의 튜플** 인 (a1, ... , an) 형식으로 표현될 수 있으며, 이때 인덱스의 속성은 A1, ..., An 이다.
- 검색 키 값의 순서는 **lexicographic ordering(사전적 순서)** 이다.





# QA)

## 1번째)

- 실제 Disk에 저장하고 식별하는 Physical Storage에서 사용하는 개념은 Physical disk address이고 물리적 데이터 단위인 Sector를 지정. Sector number로 식별
- 논리적인 개념으로 구분하기 위한 Logical disk address로 모든 데이터를 Block으로 쪼개서 해당 Block의 number를 부여하여 Block들의 리스트를 만든다.
- 데이터베이스 블록안에서 또 더 작은 단위인 Record로 나눈다.
- 인덱스 Record는 이런 Block의 search key값과 pointer로 구성되어 있다.
	- 즉, Block에서 레코드들을 찾는 index이다.
- 인덱스 Record의 pointer는 디스크 블록의 식별자 + 블록 안에서 레코드를 구별하기 위한 **offset(오프셋)** 
	- 블록안에 여러 레코드로 다시 쪼개져 있기 때문에 offset을 통해서 블록 안에서 레코드를 식별함.
- Physical (물리적인 개념)
	- Sector로 물리적 데이터 단위로 나누고 Sector number로 식별
- Logical (논리적인 개념)
	- 블록 -> 데이터베이스 파일 -> 레코드 -> Field
- Logical한 Address를 Physical한 Address로 변환하는 작업은 어떻게 하지?
	- 그래픽 카드를 예시로 생각 해보면 그래픽 카드를 추가 한 후에 소프트웨어로 그래픽 카드 드라이버를 설치 하는데 이때 그래픽 카드 드라이버가 Logical Storage Address를 Physical Storage Address로 변환 해주는 역할을 한다.
- 왜 Physical과 Logical로 나누었을까?
	- 메인 메모리와 가상메모리에서 논리주소와 물리주소를 나눈것과 같은 맥락이다.

## 2번째)

- 왜 클러스터링 인덱스는 희소 인덱스 또는 밀집 인덱스 일 수 있고 논클러스터링 인덱스는 밀집 인덱스여야만 할까?
	- **클러스터링 인덱스는 순차적으로 저장된 파일의 속성을 기반으로 Search key를 만드는 인덱스** 
		- Dense 인덱스에서는 당연히 사용 가능하다.
			- 0-> 0, 1-> 1, 2-> 2 ...
		- Sparse 인덱스에서 사용 할 수 있는 이유는?
			- 이미 클러스터링 인덱스자체가 정렬 되어 있기 상태이기 때문에
	- **논클러스터링 인덱스는 왜 Dense 인덱스만 가능할까?**
		- 논클러스터링 인덱스 자체가 물리적 파일 순차를 보장하지 않고 Search key를 만드는 방식이기 때문에 Sparse 인덱스를 사용하기 위해서 Sparse index를 구성하기 위한 정렬된것에 대한 정보가 필요한데 논클러스터링 인덱스는 그런 정보가 없기 때문이다.


# OS 개념

- 메인메모리, 가상메모리 (9장 ~ 10장)
- Disk System, File System (11장 ~12장)

# 데이터베이스에서 인덱스 찾는 과정 이해

- 밀집 인덱스에 클러스터링 인덱스에 순차 인덱스 파일인 경우
- 데이터베이스 시스템 -> 물리적 address 와 Sector number로 Sector를 찾음


# 데이터베이스 인덱스 갱신 과정 이해

