---
title: 15-4) Sorting
permalink: /cs/database/database-system-7th/ch-15-4-sorting
tags:
  - Database
layout: page
---

## Sorting

![](/assets/database-system-15-01.png)

- 정렬 (Sorting)
	- 정렬이란?
		- 데이터를 정렬하는것을 말한다.
	- 실제 쿼리에서 어떤 구문인가?
		- **ORDER BY절** 
	- 정렬이 왜 필요할까?
		- 1) SQL 쿼리 결과를 정렬된 형태로 얻을 수 있도록 정렬 연산을 명시할 수 있다.
		- 2) 조인과 같은 몇몇 관계 연산은 입력 릴레이션이 먼저 정렬되어 있는 경우에 효율적으로 구현할 수 있기 때문에
	- 정렬에 관한 2가지 문제
		- 1) 릴레이션이 메인 메모리에 모두 올라갈 수 있는 경우
			- *메모리 기반 정렬*
				- **왜 테이블이 메모리에 다 올라가는 경우에 merge sort를 사용하지 않을까?** 
					- 메인 메모리가 훨씬 빠르니까 굳이 external merge sort로 run(런)들을 디스크에 저장 할 필요가 없음.
					- *메인메모리에서 퀵정렬을 주로 사용하는 이유가 퀵정렬을 새로운 공간을 필요로 하지 않는 in-place 정렬이기 때문* 
					- merge sort는 공간을 필요로 하는 non-in-place 정렬이다.
			- quick sort
				- 1) **피벗(Pivot)** 하나를 선택
				- 2) 피벗보다 **작은 값은 왼쪽**, **큰 값은 오른쪽**으로 나눔
				- 3) 나눠진 **왼쪽/오른쪽 영역 각각에 대해 재귀적으로 퀵 정렬** 수행
				- **EX)`[7, 2, 1, 9, 5]`** 
					- **피벗 선택** → 예: `5`
					- `5`보다 작은 값: `[2, 1]`, `5`보다 큰 값: `[7, 9]`
					- 재귀 정렬:
						- `[2, 1]` → `pivot=2` → `[1] + 2 + []` → `[1, 2]`
						- `[7, 9]` → `pivot=7` → `[] + 7 + [9]` → `[7, 9]`
					- 병합 결과:
						- `[1, 2] + 5 + [7, 9]` → `[1, 2, 5, 7, 9]`
		- 2) 릴레이션이 메모리 보다 큰 경우
			- *Disk 기반 정렬* 
				- 정렬된 런을 저장 disk, 메모리에 정렬된 런들을 저장 할 수 없음
			- 왜 **merge sort 알고리즘을 사용하나?** 
				- Disk를 물리적인 순서로 정렬을 위해서 정렬된 *run(런)* 을 생성하여 디스크에 저장하기 때문에 랜덤 접근이 아닌 순차적근이 가능하게 할 수 있다.
			- **external merge-sort(외부 합병정렬)** 
	- external merge sorting (외부 합병 정렬) 알고리즘
		- 데이터가 너무 커서 메모리에 올리지 못하는 상황에서 외부에서 정렬을 수행하는 알고리즘
		- **어떻게 동작?** 
			- merge sort 알고리즘처럼 여러개의 정렬된 것들로 잘게 쪼갠다. 이를 **run(런)** 을 생성한다고 한다.
			- merge sort 알고리즘을 수행한다. 즉, 여러개의 런들을 **merge** 하여 정렬된 런을 만들어 나가면서 최종적으로 정렬된 릴레이션을 완성한다.
		- 왜 외부 합병 정렬을 사용할까?
			- *릴레이션의 크기가 너무 커서 전부 메모리에 올릴 수 없기 때문에* 메모리에 올려서 정렬을 수행 할 수 없다.
			- 그래서 메모리의 일정 부분만의 공간을 차지하여 정렬된 런들을 **merge** 하여서 해당 메모리에 정렬된 run들을 만들어 나가는 방식이다.
			- **정렬된 run들을 각각 하나의 블록에 할당하고 결과를 하나의 페이지에 남긴다** 

