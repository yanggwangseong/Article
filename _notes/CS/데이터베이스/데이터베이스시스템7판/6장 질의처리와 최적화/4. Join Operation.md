---
title: 15-5) Join Operation
permalink: /cs/database/database-system-7th/ch-15-5-join-operation
tags:
  - Database
layout: page
---

## Join Operation

- 조인 연산이란?
	- 릴레이션의 조인을 계산하는 연산이다.
- **실제 SQL 쿼리에서 조인 종류**
	- INNER JOIN
		- 양쪽 테이블에 조건이 **일치하는 행만** 반환
	- LEFT JOIN (또는 LEFT OUTER JOIN)
		- 왼쪽 테이블의 **모든 행을 유지**, 오른쪽이 없으면 `NULL`
	- RIGHT JOIN (또는 RIGHT OUTER JOIN)
		- 오른쪽 테이블의 **모든 행을 유지**, 왼쪽이 없으면 `NULL` 
	- FULL JOIN (또는 FULL OUTER JOIN)
		- 양쪽 테이블의 **모든 행을 유지**, 매칭 안 되면 `NULL` 
	- CROSS JOIN
		- 두 테이블 간 **모든 조합** (카티전 곱) 반환
- 알고리즘
	- Nested Loop Join
		- Linear Search(선형 탐색) 방식의 중첩 루프 방식의 조인 알고리즘
		- **내가 Optimizer라면 어떤 상황에 어떤 조인 알고리즘을 선택할까?**
			- 조인 조건에 **인덱스가 있을 때** (특히 Inner 테이블에) 조인 대상 테이블 중 **한쪽이 매우 작을 때** (소규모 + 반복) 반복이 적고, 빠르게 조건을 만족할 가능성이 높을 때
			- 왜 인덱스 **(특히 Inner 테이블에)** ?
				- 중첩 루프 방식의 탐색이기 때문에
			- 왜 한쪽 테이블이 매우 작거나 반복이 적을때 사용하나?
				- 중첩 루프 방식의 탐색이므로 두개의 테이블이 모두 크다면 특히나 Inner 테이블이 크다면 탐색이 비효율적이다.
			- EX) Inner가 10개, Outer 1000개, Inner 1000개, Outer가 10개
			- EX) Inner 테이블에 인덱스가 있을때
		- **EX 쿼리)**
		- *어떻게 동작할까?* 
		- **특징** 
			- 인덱스 있음 or 한쪽이 매우 작음
		- **단점** 
			- *두 테이블 다 크면 비효율*
	- Merge Join
		- **양쪽 테이블이 정렬되어 있다는 전제** 하에, **두 포인터로 순차적으로 병합**하는 방식의 조인
		- *equi-join 과 Natural Join에서 사용* 
		- **내가 Optimizer라면 어떤 상황에 어떤 조인 알고리즘을 선택할까?**
			- *두개의 테이블이 정렬되어 있고 범위 조인이 필요한 경우* 
			- 조인 조건이 **등호(=)** 이고 **양쪽 테이블이 정렬된 상태이거나**, 정렬 인덱스가 있어서 **정렬 비용이 낮을 때** 
			- **범위 기반 조인**이 유리한 경우 (e.g., `BETWEEN`, `LIKE 'a%'`)
			- 테이블이 모두 **중간 이상 크기이지만, 정렬이 되어 있어 탐색 효율이 높은 경우** 
		- **왜 정렬이 전제되어야 할까?** 
			- Merge Join은 정렬된 상태에서 포인터 두 개로 동시에 비교하며 나아가는 방식이기 때문에, **정렬이 안 되어 있다면 먼저 정렬 작업(Sort)이 필요**하고, 이 비용이 커질 수 있음.
		- *어떻게 동작할까?* 
			- 1) 각각의 테이블에 하나씩 포인터를 둔 상태 (이미 정렬되어 있다고 가정 아니면 merge-sort 연산 비용 발생)
			- 2) p1 : A테이블 첫번째 튜플 , p2 : B테이블 첫번째 튜플 가리키고 있는 상태
			- 3) p1의 id: 1, -> p2를 루프 돌면서 id:1을 찾음 즉, p1의 id:1에 교집합에 해당하는 튜플들을 찾고 종료
			- 4) p1을 다음 포인터로 이동 id: 2, 이때 B테이블에 id:1을 이미 다 찾았기 때문에 id :1보다 큰 id:2로 포인터 이동
			- **핵심은 이전에 찾았던 p1에 해당하는 p2를 다시 찾지 않는 투포인터 알고리즘 방식** 
		- **EX 쿼리)**
		- 조건
			- 양쪽이 정렬되어 있음
				- 정렬된 데이터에 병합 탐색이 효율적
			- 정렬 인덱스가 존재함
				- 정렬 비용 없이 Merge Join 사용 가능
			- 범위 조인에 강함
				- 연속된 키 값을 순차 비교하기 때문에
			- 조인 키가 등호(=)
				- 반드시 정렬 기준이 있어야 하므로
		- **특징** 
			- 양쪽 정렬되어 있음
			- 범위 조인, 연속 키 조인 효율적
		- **단점**
			- **정렬 안 되면 사용 불가**
	- Hash Join
		- **한쪽 테이블(보통 작은 쪽)** 을 해시 테이블로 메모리에 올려서,다른 테이블을 스캔하면서 해시로 빠르게 매칭하는 조인 방식입니다.
		- 조건
			- 조인 조건이 **등호(=)** 
			- 두 테이블 모두 **정렬이 안 되어 있음**
			- 인덱스도 없음
			- 그리고 한쪽 테이블은 **메모리에 해시 테이블로 올릴 수 있을 정도의 크기** 
		- **왜 해시로?** 
			- 인덱스도 없고 정렬도 안 돼 있다면, 조인을 하려면 **풀 스캔**해야 함 이때 한쪽 테이블을 해시 테이블로 만들어 놓으면 **검색이 O(1)** 수준이라 효율적
		- **해시함수** 
			- 무작위성과 균일성을 "좋은 점"으로 가지고 있어야 한다.
		- *어떻게 동작할까?* 
			- **해시 join은 메모리에 두개의 테이블을 올리지 않고 한쪽 테이블만 올린 후에 해당 한쪽 테이블의 조인 key값을 해싱 하여 다른 테이블의 key를 찾아서 조인 하는 알고리즘** 
			- *좀 더 크기가 작은 테이블을 메모리에 올린다.* 
			- 한쪽 테이블의 key값을 해싱함수로 해싱한 값과 다른 테이블의 key값을 해싱함수로 해싱한 값이 같기 때문에
			- 한쪽 테이블만 메모리에 올려서 해당하는 튜플의 key값으로 해싱하여 찾는 알고리즘이다.
		- **내가 Optimizer라면 어떤 상황에 어떤 조인 알고리즘을 선택할까?**
			- 조인 조건이 등호조건(=)에 두 테이블이 모두 정렬이 되어 있지 않고 인덱스가 없을때 한쪽 테이블이 메모리에 해시테이블로 올릴 수 있을 정도의 크기인 경우
		- *CASE1) 테이블 둘다 해시테이블을 메모리에 아예 올릴 수 없을경우?* 
			- 둘다 테이블이 메모리 버퍼에 올라갈수 없는경우에도 해시조인을 사용할 수 있는데 그 이유가 해시테이블을 다계층으로 만드는 방법
		- *CASE2) 오버플로 처리* 
			- 오버플로가 왜 발생할까?
				- 해시테이블이 올라간 테이블에 조인 속성에 대해 같은 값을 가지는 튜플이 많은 경우 발생
				- *해시함수의 randomness(랜덤성)과 uniformity(균등성)의 속성을 가지지 못하는 경우 발생* 
				- EX) A테이블에 조인 속성이 fruit에서 "apple" 이 100개나 중복되고 있는 경우에서의 조인 (논유니크)
			- *Bucket skewed(버킷 쏠림)* 
				- Bucket skewed(버킷 쏠림)이란 조인 속성에 중복 데이터가 많다보니 해당 중복 데이터의 해시값은 동일하므로 특정 버킷에 튜플들이 쏠리는 현상
			- **해결방법)** 
				- **overflow resolution(오버플로 분해)** 
					- 해시 인덱스 오버플로가 발견되는 경우에 수행된다.(해시 충돌 말하는듯)
					- 해당 버킷이 너무 커지게 된 경우에 또다른 해시 함수를 통해서 더 작은 버킷으로 분할한다.
						- *쏠린 버킷을 다시 해싱하여 하위 버킷으로 분할* 
					- 이때 반대편의 대상 테이블도 똑같이 새로운 해시함수로 더 작은 버킷으로 분할 하여 서로 조인을 수행한다.
				- **overflow avoidance(오버플로 방지)** 
					- **처음부터 쏠림이 생기지 않도록 설계**하는 방식
					- 어떻게?
						- 처음부터 많은 작은 버킷으로 쪼갠후에 몇몇개의 버킷을 메모리 크기에 맞도록 **merge하는 작업**을 수행한다.
						- *메모리에 올라가는 해싱테이블만*  검색용 해시테이블은 아님 처음부터 해시 테이블의 버킷들을 더욱 잘게 쪼갠후에 원래 기존에는 10개의 버킷이었다면 지금은 100개의 버킷으로 처음부터 만든후에 만약 해싱값이 3이라면 해당 버킷이 조금 찬다면 3버킷과 4버킷을 merge 해버려서 3버킷의 공간을 더 확보하는 방식
							- 해싱하는 메모리에 올라간 테이블은 버킷이 1000개로 그냥 만듬
							- 검색용 해시테이블은 버킷을 10개
							- 예를 들어 해싱값이 10에 많은 튜플이 쏠린다면 이때 다른 여유 버킷들을 메모리 크기에 맞게 merge하여 올림
