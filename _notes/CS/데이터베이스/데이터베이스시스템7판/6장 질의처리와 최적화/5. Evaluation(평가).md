---
title: 15-7-Evaluation
permalink: /cs/database/database-system-7th/ch-15-7-Evaluation
tags:
  - Database
layout: page
---
- Materialized(실체화)
	- 적당한 순서로 한번에 하나씩 연산을 평가하는 방법
	- 각 연산 결과를 임시테이블에 실체화되어 나중에 사용될 수 있다.
- 파이프라이닝
	- 여러개의 연산을 파이프라인에서 동시에 수행하는 방법

## Materialized(실체화)

( 예시 쿼리 )

![[Pasted image 20250417232552.png]]

**expression (표현식)** 

![[Pasted image 20250418002402.png]]

**operator tree(연산자 트리)** 

![[Pasted image 20250418002643.png]]

**실체화 접근 방법 적용**

1. 표현식의 가장 낮은 단계(트리의 제일 아랫부분)의 연산부터 수행하게 된다.
	- EX) `department` 에 대한 선택 연산이 가장 낮은 단계의 연산이 된다.
	- 가장 낮은 단계의 연산에 대한 입력은 데이터베이스 내의 릴레이션이다.
	- 선택 연산을 수행한 후 결과를 임시 릴레이션에 저장해 놓을 수 있다.
2. 해당 임시 저장된 릴레이션을 이용해 트리의 다음 단계에 있는 연산을 수행할 수 있다.
	- 이때 입력은 임시 릴레이션이나 데이터베이스 내의 릴레이션이 될 수 있다.
	- EX) 조인 연산은 `instructor` 릴레이션과 `department` 릴레이션에 선택 연산을 수행해서 얻은 임시 릴레이션을 입력으로 가지게 된다.
		- 이 두 입력 릴레이션을 가지고 조인을 수행한 후 다시 또 다른 임시 릴레이션을 생성한다.
3. 이러한 과정을 반복하면서 트리의 루트에 해당하는 연산을 평가하게 되고, 표현식의 결과를 얻어 내게 된다.
	- EX) 조인연산에 의해 생성된 임시 릴레이션을 입력으로 사용해 트리의 루트에 해당하는 추출 연산을 수행함으로써 표현식의 결과를 얻어낼 수 있다.
- **이렇게 표현식을 평가하는 방법을 materialized evaluation(실체화 평가)** 라고 한다.
- **실체화 평가의 Cost는 연산들의 알고리즘말고도 디스크 I/O 비용도 포함해야 한다** 

결과 레코드가 출력 버퍼에 계속 쌓이고 출력 버퍼가 꽉 차는 경우 버퍼를 디스크에 쓴다.

## Pipelining

- 파이프라이닝이란?
	- 하나의 연산의 결과를 파이프라인을 통해 다음 연산으로 넘겨주는 방법
- 왜 필요할까?
	- 연산의 중간 결과로 생성되는 임시 파일의 수를 줄여 쿼리 처리의 효율성을 향상할 수 있다.
- EX) Materialized 방식을 사용 한다면 조인의 결과를 저장하기 위한 임시 릴레이션을 생성하고 그 릴레이션을 추출 연산을 수행하기 위해 다시 읽어 들인다.
	- 하지만 파이프라이닝 방식을 사용하면 조인 연산이 결과로 하나의 튜플을 만들어 낼때마다 그 튜플을 즉시 추출 연산의 입력으로 넘겨준다.
	- 조인과 추출 연산을 합침으로써 중간 결과를 생성하지 않아도 되고 대신에 곧바로 식의 결과를 얻어 낼 수 있다.

### 파이프라이닝 구현

- 파이프라이닝이 필요한 여러 개의 연산을 하나로 묶어서 하나의 복잡한 연산을 구성함으로써 파이프라인을 구현 할 수 있다.

![[Pasted image 20250418002643.png]]

- 해당 예제에서 각 연산은 파이프라인 내에 위치할 수 있으며, 
- 이때 선택 연산의 결과가 나올때마다 조인 연산의 입력으로 보내줄 수 있으며
- 조인 연산의 결과가 나올때마다 추출 연산의 입력으로 보내 줄 수 있다.
- **한 연산의 결과가 오랫동안 메모리에 남아 있지 않아 메모리 절약** 
- **연산의 입력으로 들어가는 데이터는 처리할 당시에만 존재하게 되고 이후에는 재사용 할 수 없다** 


- **demand driven pipeline (요구 구동 파이프 라인)** 
	- 시스템은 파이프라인의 상층부에 있는 연산으로부터 튜플에 대한 요구를 반복시키게 된다.
	- 각 연산이 튜플 요구를 받아들일 때마다 각 연산은 다음 튜플을 계산한 후 그 결과를 넘겨준다.
	- 연산의 입력이 파이프라인이 아닌 경우 다음번에 넘겨줘야 할 튜플은 입력 릴레이션으로부터 계산된다.
	- 각 연산은 자신의 입력을 파이프라인으로부터 요구하면 결과를 계산한 후 그 결과를 자신의 부모 연산에게 넘겨준다.
- **producer driven pipeline (생산자 구동 파이프라인)** 
	- 각 연산은 튜플에 대한 요구를 기다리지 않고, 튜플을 **즉시(eagerly)** 생성한다.
	- 생산자 driven pipeline에서 각 연산은 (파이프라인된 입력에서 특정 튜플을 가져와 그 입력에 대한 특정 튜플을 생성하는) 시스템 내의 별도의 프로세스 또는 스레드로 모델링된다.
- demand driven pipeline 구현 방법
	- 각 연산은 `open()` , `next()` , `close()` 와 같은 함수를 제공하는 **iterator(반복자)** 를 이용해 구현 할 수 있다.
	- `open()` 함수를 호출 한 후 `next()` 함수를 호출할 때 마다 연산의 다음번 결과를 넘겨준다.
	- `close()` 더이상 튜플이 필요하지 않은 경우 호출된다.
	- iterator는 각 함수 호출마다 수행 상태(state)를 유지함으로써 연속된 `next()` 함수의 호출이 연속되는 결과 튜플을 넘겨줄 수 있도록 한다.
- producer driven pipeline 구현 방법
	- 생산자 driven pipeline의 인접한 연산자의 각각의 짝에 대해, 시스템은 하나의 연산자에서 다음 연산자로 넘겨지는 튜플을 유지하기 위한 버퍼를 생성한다.
	- 서로 다른 연산에 상응하는 프로세스나 스레드는 동시에 실행한다.
	- 파이프라인의 아래쪽에 있는 연산은 출력 버퍼가 꽉 찰 때까지 계속해서 결과를 만들어 내어 출력 버퍼에 담아둔다.
	- 파이프라인의 위쪽에 있는 연산은 파이프라인의 아래쪽에서 입력 튜플을 받는 경우에 출력 버퍼가 꽉 찰때까지 연산을 수행한다.
	- 각 연산은 파이프라인 입력으로부터 튜플을 얻어 올때마다 입력 버퍼에서 그 튜플을 삭제한다.
	- 출력 버퍼가 꽉 차는 경우 각 연산은 자신의 부모 연산이 버퍼로부터 튜플을 삭제해서 버퍼에 여분의 공간이 생길때까지 기다린다.
	- 그런 후에 자신의 출력 버퍼가 다시 꽉 찰때까지 연산을 수행한다.
	- 각 연산의 전체 결과가 모두 생성될때까지 이 과정을 반복한다.
	- 출력 버퍼가 가득차거나, 입력 버퍼가 비어 있고 더 많은 출력 튜플을 생성하기 위해 더 많은 입력 튜플이 필요한 경우에만 시스템이 연산 간에 전환한다.
	- 병렬 처리 시스템의 경우 하나의 파이프라인 내에 있는 여러 개의 연산이 서로 다른 프로세서에서 동시에 수행될 수 있다.

- **생산자 driven 파이프라인** 을 사용하는 것은 연산자 트리의 아래에서 위로 데이터를 **pushing(밀어 올리는것)** 과 같다.
	- 튜플을 미리(eagerly) 만든다.
	- 생산자 구동 파이프라인은 병렬 처리 시스템에서 매우 유용하게 사용된다.
	- **디멘드 구동 파이프라인보다 함수 호출 수를 줄일 수 있으므로, 최신 CPU에서 더 효율적이다** 
	- 고성능 쿼리 평가를 위해 기계어 코드를 생성하는 시스템에서 점점 더 많이 사용되고 있다.
- **Demand driven 파이프라인** 은 연산자 트리의 위에서 아래에 있는 데이터를 **pulling(끌어올리는 것)** 과 같다고 할 수 있다.
	- 튜플을 **요구가 있을 때에만(lazily)** 튜플을 만든다.
	- 구현의 편의성 때문에 생산자 구동 파이프라인보다는 요구 구동 파이프라인이 더 많이 사용된다.


### 파이프라이닝 수행 알고리즘

- pipelined edge
	- 파이프라이닝에서 쿼리 계획의 Edge에 주석을 달아 표현한 Edge
- materialized edge
	- 쿼리 계획에서 파이프라이닝을 사용하지 않는 Edge

파이프라인된 간선으로 연결된 두 연산자는 동시에 실행되어야 하며, 이는 한 연산자가 튜플을 생성할 때마다 다른 연산자가 생성된 튜플을 사용해야 하기 때문이다.

**Sorting 연산은 blocking operation(블로킹하는 연산)** 이다.

![[Pasted image 20250418191746.png]]

- 정렬
- 조인


### 연속된 스트림 데이터에 대한 파이프라이닝

- data stream(데이터 스트림)
	- 데이터가 지속적으로 입력되는 상황의 데이터
- continuous query(연속 쿼리)
	- 데이터가 도착할 때마다 응답하기 위해 스트림 데이터에 대해 쿼리를 작성하는 쿼리
- 많은 연속 쿼리는 윈도우를 사용하여 집계를 수행한다.
- tumbling window (텀블링 윈도우)
	- 시간을 1분 또는 1시간과 같이 고정된 간격으로 나누는 방식