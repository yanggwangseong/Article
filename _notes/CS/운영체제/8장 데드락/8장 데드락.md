---
title: ch-8-데드락
permalink: /cs/os/operation-system/ch-8-데드락
tags:
  - OS
layout: page
---
# Livelock(라이브락)

## LiveLock이란?

- 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.
- 두개 이상의 스레드가 진행되는것을 방해하지만 스레드가 실패한 행동을 계속해서 시도할 때 발생한다.
	- ex) 두사람이 복도에서 스쳐 지나갈 때 한 사람이 오른쪽으로 갈려고 하고 반대편 사람이 왼쪽으로 갈려고 하면서 서로 진행을 방해하는거.
## LiveLock 회피조건

- 스레드가 실패한 작업을 동시에 재시도 할 때 발생하기 때문에 각 스레드가 실패한 행동을 재시도하는 시간을무작위로 정하면 회피할 수 있다.



# DeadLock(교착상태)란? ⭐️
- **여러 프로세스나 스레드가 자원을 요청할 때 각 프로세스가 다른 프로세스가 보유한 자원을 기다리면서, 그 자원들이 동시에 다른 프로세스에 의해 요구되어 아무도 진행하지 못하고 영원히 기다리는 상태를 말합니다.** 

# DeadLock 필요 조건들 ⭐️

**한 시스템에 네가지 조건이 동시에 성립될 때 발생할 수 있다.** 

## 1. mutual exclustion (상호배제) ⭐️

- 여러 프로세스나 쓰레드가 공유 자원에 접근할 때, 동시에 접근하는 것을 방지하는 기법입니다.
- 최소한 하나의 자원이 `non-sharable(비공유 모드)` 로 점유 되어야 한다.
	- ex) 파일 읽기/쓰기 접근
		- 공유 가능(Sharable)한 경우
			- 5개의 쓰레드가 읽기 전용 모드로 하나의 파일에 접근하는 상황입니다. 읽기만 수행할 경우, 파일에 동시에 접근해도 문제가 없습니다.
		- 공유 불가능(Non-sharable)한 경우
			- 만약 1개의 쓰레드가 쓰기 작업을 하려 한다면, 쓰기 작업은 다른 읽기 작업과 동시에 수행될 수 없습니다.

## 2. hold-and-wait (점유하며 대기) ⭐️

- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드기 waiting(대기)해야 한다.

## 3. no preemption (비선점) ⭐️

- 자원들을 선점할 수 없어야 한다.
	- 즉, 자원이 강제적으로 방출될 수 없고, 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.

## 4. circular wait (순환 대기) ⭐️

- 서로 waiting(대기)하고 있는 스레드의 집합은 이들의 waiting에 대한 의존 그래프가 (circular)순환적이다.

# Resource-Allocation Graph(자원 할당 그래프)

- DeadLock(교착 상태)는 시스템 자원 할당 그래프라고 하는 방향 그래프로 정점(vertex) V의 집합과 간선(edge) E의 집합으로 구성되고 해당 그래프로 기술 할 수 있다.
- 자원 할당 그래프에 사이클이 없다면 시스템은 교착 상태가 아니다.
- 사이클이 있다면 시스템은 교착 상태일 수 도 있고 아닐 수 도 있다.



# Methods for Handling DeadLock (교착 상태 처리 방법)

1. 문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척한다.
	- Linux와 Windows를 포함해 대부분의 운영체제가 사용하는 방법이다.
2. 시스템이 결코 교착 상태가 되지 않도록 보장하기 위하여 Deadlock Prevention(교착상태 예방), Deadlock Avoidance(교착상태 회피)하는 프로토콜을 사용한다.
3. 시스템이 교착 상태가 되도록 허용한 다음에 복구 시키는 방법이 있다.
	- Deadlock Detection (교착 상태 탐지), Recovery from Deadlock (교착 상태로부터 회복)


# Deadlock Prevention (교착 상태 예방) ⭐️

- 데드락 발생의 4가지 필요조건중에서 최소한 하나가 성립하지 않도록 보장함으로써 데드락의 발생을 Prevention(예방)할 수 있다.
- **실제 프로그램에서 적용 할 수 없다. 그나마 circular wait를 사용 할 수 있는데 이것 또한 마찬가지로 락이 동적으로 획득될 수 있는 경우 교착 상태를 완전히 방지할 수 있다는 보장은 없다.** 

## mutual exclustion (상호배제)

- 적어도 하나의 자원은 non-sharable한 자원이어야 한다
- 일반적으로 상호배제 조건을 거부함으로써 교착 상태를 예방하는 것은 불가능하다.

## hold-and-wait (점유하며 대기)

- 점유와 대기가 발생하지 않도록 하려면 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장 해야한다.
- 방법1) 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당 해야 한다.
	- (자원요청의 동적 특성 때문에 응용 프로그램에서 실용적이지 않다)
- 방법2) 스레드가 자원을 전혀 갖고 있지 않을때만 자원 요청, 스레드가 추가의 자원을 요청할 수 있으려면 자신에게 할당된 모든 자원을 반드시 먼저 방출해야 한다.
- 방법1과 방법2의 2가지 단점
	- 자원이 할당되었지만 장기간 사용되지 않을 수 있기 때문에 자원 이용률이 낮을 수 있다.
	- Starvation(기아)가 발생할 수 있다.

**일반적으로 대부분의 응용 프로그램에 적용할 수 없습니다.** 
## no preemption (비선점)

- 자원을 선점할 수 있도록 보장하는 프로토콜을 사용할 수 있습니다.
- 만약 스레드가 일부 자원을 보유한 상태에서 다른 자원을 요청했을 때
	- 그 자원을 즉시 할당할 수 없다면,
	- 스레드가 현재 보유하고 있는 모든 자원이 선점됩니다.
- 선점된 자원들은
	- 스레드가 기다리고 있는 자원 목록에 추가됩니다
- 스레드는 다음과 같은 경우에만 다시 시작됩니다
	- 이전에 보유했던 자원과 새로 요청한 자원을 모두 다시 확보할 수 있을 때

**일반적으로 대부분의 응용 프로그램에 적용할 수 없습니다.** 


## circular wait (순환 대기)

- 프로토콜1) 모든 자원 유형에 대해 전체 순서를 부여합니다.
	- 예를 들어, 자원 A, B, C가 있다면 A → B → C 순으로 순서를 정합니다.
- 프로토콜2) 각 스레드는 자원을 요청할 때 부여된 순서에 따라 증가하는 순서로 요청해야 합니다.
	- 스레드는 A를 먼저 요청한 후에만 B를 요청할 수 있고, B를 획득한 후에만 C를 요청할 수 있습니다.
- 이 두 가지 프로토콜이 사용되면,
	- 순환 대기 조건은 성립할 수 없음을 입증할 수 있습니다.
- 락 순서를 강제한다고 해도,
- 락이 동적으로 획득될 수 있는 경우 교착 상태를 완전히 방지할 수 있다는 보장은 없습니다.

# Deadlock Avoidance (교착 상태 회피) ⭐️

## Deadlock Avoidance (교착 상태 회피)란?

- 시스템이 각 요청에 대해, 해당 스레드가 향후 교착 상태를 피하기 위해 기다려야 할지 여부를 결정하도록 합니다.
- 이를 위해서는, 자원이 어떻게 요청될 것인지에 대한 추가 정보가 필요합니다.
- 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것이다.
- **실제로 사용 하기에 뱅커스 알고리즘은 자원을 요청할 때마다 실행되므로 시스템에 굉장히 큰 부담이다. 그래서 아주 중요한 시스템 절대로 DeadLock(교착상태)가 발생하면 안되는 시스템에 적용** 


## Safe State (안전 상태)

- 시스템 상태가 safe(안전)하다는 말은 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 할당할 수 있으며, 이 과정에서 교착 상태가 발생하지 않는 상태를 의미합니다.
- 시스템이 safe sequence(안전 순서)를 찾을 수 있다면 시스템은 안전 상태이며, 즉 교착 상태가 발생하지 않는다고 할 수 있습니다.

![](/assets/database-deadlock01.png)

- *safe state* 는 교착 상태가 아닙니다.
- deadlock은 *unsafe state* 입니다.
- 그러나 모든 unsafe state가 교착 상태인것은 아닙니다.
	- 다만 unsafe state는 교착 상태로 이어질 수 있습니다.

## 교착 상태 회피 알고리즘
### Avoidance(회피) 알고리즘이 어떻게 교착 상태를 회피하는가?

- 회피 알고리즘은 시스템이 절대 교착 상태에 들어가지 않도록 보장합니다.
- 이 알고리즘의 기본 개념은 시스템이 항상 *safe state* 를 유지하도록 하는 것입니다.
- 초기에는 시스템이 *safe state* 에 있습니다.
- 스레드가 현재 사용 가능한 자원을 요청할 때마다, 시스템은 그 자원을 할당할 수 있을지 여부를 결정합니다.
- 요청이 승인되는 것은, 자원을 할당했을 때 시스템이 여전히 *safe state* 를 유지할 수 있는 경우에만 가능합니다.

### 1. Resource-Allocation Graph Algorithm (자원 할당 그래프 알고리즘)

- 각 자원 유형에 1개의 인스턴스만 존재 할때 사용합니다.
- 시스템에 각 자원 유형의 인스턴스가 하나만 있다고 가정합니다.
- 이때, claim edge(예약 간선)라는 새로운 유형의 엣지를 도입합니다.
- claim edge(예약 간선)는 스레드가 미래에 자원을 요청할 수 있음을 나타냅니다.
- 그러면, 방향 그래프에서 사이클을 탐지하는 알고리즘을 사용해 시스템의 안전성을 확인할 수 있습니다.
- 사이클이 존재하지 않으면, 요청을 즉시 승인할 수 있습니다.
	- 이 경우, 자원 할당 후에도 시스템이 안전 상태를 유지합니다.
- 사이클이 감지되면, 요청을 승인할 수 없습니다.
	- 이 경우, 자원 할당이 시스템을 안전하지 않은 상태로 만들기 때문입니다.


#### DeadLock Avoidance (교착상태 회피) 자원 할당 그래프

![](/assets/database-deadlock02.png)


#### Unsafe State (불안정 상태) 자원 할당 그래프

![](/assets/database-deadlock03.png)

### 2. Banker's Algorithm (은행원 알고리즘)

#### Resource Type(자원의 종류)과 Resource(자원) 란?

- Resource Type이란 시스템에서 관리하는 자원의 종류이다.
	- ex) 프린터, 스캐너, USB포트 등
- Resource(자원) 란
	- 특정 Resource Type에 속하는 구체적인 자원을 의미합니다.
	- 시스템에서 할당될 수 있는 실제 자원을 나타냅니다.
	- ex) 프린터 유형에 속하는 프린터 1대
	- ex) 스캐너 유형에 속한 스캐너 1대
	- ex) USB 포트 유형에 속한 USB 포트 1개
- Instance(인스턴스) 란
	- 자원(Resource)의 개별 실체를 의미합니다.
	- 각 인스턴스는 자원의 구체적인 할당 가능한 단위를 나타냅니다.
		- ex) 프린터 1번, 프린터 2번
		- ex) USB 포트 1번, USB 포트 2번


#### 은행원 알고리즘이 왜 필요한가?

- 자원 할당 그래프 알고리즘은 종류마다 자원이 여러개씩 있게 되면 사용할 수 없다.
- 자원 유형마다 여러 개의 인스턴스가 있는 경우, 자원 할당 그래프 알고리즘은 적용할 수 없습니다.
- 따라서, 여러 인스턴스를 다룰 수 있는 은행원 알고리즘이 필요합니다.

#### RAG (자원 할당 그래프) 가 자원이 여러개 일때 왜 사용 하기 어려운가?

- RAG (자원 할당 그래프)는 사이클이 발생하면 교착 상태라고 판단 하는데 하지만 여러개의 자원 인스턴스가 있는 경우, 사이클이 있어도 일부 자원은 아직 할당할 수 있는 상황이 존재 할 수 있다.
- 즉, 단순한 사이클 탐지로는 시스템이 *safe state* 상태인지 아닌지 정확히 판단 할 수 없음.

#### 은행원 알고리즘 이란?

> 은행에 적용하면 고객들이 현금을 찾으러 와도 일정한 순서에 의해 모든 고객의 요청을 다 들어줄 수 있게 되기 때문이다.

- 각 자원 유형에 여러 개의 인스턴스가 존재할 때 사용합니다.
- 스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고하여야 한다.
- 물론 이 숫자가 자원의 총 보유 수를 넘어서면 안된다.
- 스레드가 자원들을 요청하면 시스템은 그것을 들어줄 때 시스템이 계속 *safe state* 에 머무르게 되는지 여부를 판단 해야 한다.
- 만약 계속 *safe state* 라면 그 요청을 들어준다.
- 만약 그렇지 않다면 *unsafe state* 라면 이 스레드의 요청은 허락이 안된채 다른 스레드가 끝날 때까지 기다리게 된다.

#### 은행원 알고리즘의 자료구조

- Available : 각 종류별로 가용한 자원의 개수를 나타내는 vector로 크기가 m이다.
- Max : 각 스레드가 최대로 필요로 최대 자원 요구량 (Maximum Demand).
- Allocation : 각 스레드에 현재 할당된 자원의 개수.
- Need : 각 스레드가 향후 요청할 수 있는 자원의 개수.

##### Safety Algorithm (안정성 알고리즘)

- 시스템이 *safe state* 인지 아닌지를 알아낼 수 있는 알고리즘

##### Resource-Request Algorithm (자원 요청 알고리즘)

- 자원 요청이 안전하게 들어줄 수 있는지를 검사하는 알고리즘


### RGA(자원 할당 그래프 알고리즘)과 은행원 알고리즘 차이

| 특징        | 자원 할당 그래프 (RGA)                 | 은행원 알고리즘                           |
| --------- | ------------------------------- | ---------------------------------- |
| 자원 인스턴스 수 | **하나의 인스턴스**만 존재하는 경우에 사용합니다.   | **여러 개의 인스턴스**가 존재할 때 사용합니다.       |
| 교착 상태 탐지  | **사이클 탐지**를 통해 교착 상태 여부를 판단합니다. | 시스템이 **안전 상태**를 유지할 수 있는지 판단합니다.   |
| 작동 원리     | 방향 그래프에서 사이클이 있는지 검사합니다.        | 자원을 할당하기 전에 시스템이 안전 상태인지 시뮬레이션합니다. |
| 적용 시기     | 단순하고 자원이 하나씩만 필요한 시스템에 적합합니다.   | 복잡하고 자원이 여러 개 필요한 시스템에 적합합니다.      |
| 한계        | 자원 인스턴스가 여러 개일 때 적용할 수 없습니다.    | 계산이 복잡하고 오버헤드가 발생할 수 있습니다.         |

## Detection & Recovery (탐지와 회복) ⭐️

- 시스템에 Deadlock Prevention(데드락 예방), Deadlock Avoidance(데드락 회피)를 사용하지 않는다면 교착상태가 발생 할 수 있다.
- **현대 운영체제에서 주로 사용되는 방법으로, 교착 상태를 허용하고 탐지한 후 회복한다.** 

시스템은 다음 알고리즘을 반드시 지원 해야 된다.

- 교착 상태가 발생 했는지 결정하기 위해 시스템 상태를 검사하는 알고리즘
- 교착 상태로부터 회복하는 알고리즘

### Detection (탐지)

- Single Instance of Each Resource Type (각 자원 유형이 한개씩 있는 경우)
- Several Instance of Resource Type (각 유형의 자원을 여러개 가진 경우)
#### 각 자원 유형이 한개씩 있는 경우 (Single Instance of Each Resource Type)

- *모든 자원이 한개의 인스턴스만 있다면,* **wait-for-graph(대기 그래프)** 라고 하는, 자원 할당 그래프의 변형을 사용해 교착 상태 탐지 알고리즘을 정의 할 수 있다.


#### 각 유형의 자원을 여러개 가진 경우(Several Instance of a Resource Type)

- Detection-Algorithm(탐지 알고리즘)을 사용
	- 자원이 여러개 일 때 왜? 사용하나
		- wait-for-graph는 자원이 여러개씩 존재하는 상황에서는 사용할 수 없다.
		- 자원 할당 그래프에서 왜 여러 자원에서 사용 못하는지 이유가 동일하다.
	- 은행원 알고리즘과 비슷하다.


##### Detection-Algorithm (탐지 알고리즘) 사용

1. 교착 상태가 얼마나 자주 일어나는가?
2. 교착 상태가 일어나면 통상 몇개의 스레드가 거기에 연루 되는가?



- 교착 상태가 자주 일어난다면 탐지 알고리즘도 자주 돌려야 한다.
- 교착 상태가 된 스레드부터 자원을 회수하기까지는 그 자원들은 아무도 못 쓰는 자원으로 교착 상태 기간 내내 묶이게 되기 때문이다.
- 시간이 지날수록 교착 상태에 연류되는 스레드의 수 도 늘어날 수 있다.
- 요청 마다 Detection 알고리즘 호출
	- 오버헤드가 너무 크다
- 일정한 간격으로 수행하는 경우
	- 오버헤드를 줄일 수 있는 대안이다.
	- ex) 한 시간에 한번 또는 CPU 이용률이 40% 이하로 떨어질 때 탐지 알고리즘을 호출하는 것이다.


### Recovery (회복)

#### Process and Thread Termination (프로세스와 스레드의 종료)

1. 교착 상태 프로세스를 모두 중지
	- 교착 상태의 사이클을 깨지만, 그만큼 비용이 크다.
2. 교착 상태가 제거될 때까지 한 프로세스씩 중지
	- 각 프로세스가 중지 될 때 마다 교착 상태 탐지 알고리즘을 호출해 교착 상태에 있는지 확인.
		- 상당한 오버헤드를 유발한다.

#### Resource Preemption (자원 선점)

- Selection of a victim (희생자 선택)
	- 비용을 최소화하기 위해 선점 순서를 고려합니다.
- Rollback(롤백)
	- 프로세스를 안전한 상태로 롤백한 후 다시 시작합니다.
- Starvation(기아 상태)
	- 특정 프로세스가 희생자로 선택되는 횟수가 유한 해야 합니다.


# Reference

- 공룡책 8장 데드락
- https://www.youtube.com/watch?v=ESXCSNGFVto&t=84s 
