
- 가상 메모리란?
	- 보조저장 장치의 일정 부분을 메모리에서 저장 했던 것들을 담아서 사용할 때 다시 메모리에 올려 사용하는 스왑 디바이스 영역을 말합니다.
- 디멘드 페이징이란?
	- 필요한 페이지만 가상 메모리를 사용하여 프로그램 실행 중 필요할 때만 페이지가 적재된다.
- 페이지 교체 정책
	- 페이지 폴트가 발생해서 보조 저장 장치에서 페이지를 가져와서 물리 메모리에 스왑인 할 때 더이상 할당 할 수 있는 프레임이 없을때 물리 메모리에 있는 페이지를 백업 저장 장치로 보내고 그 빈 프레임에 할당하는 것을 말합니다.
- 페이지 교체 알고리즘
	- FIFO 교체 알고리즘이 뭔지?
		- 먼저 들어온것이 먼저 나가는 큐 형태의 교체 알고리즘으로 가장 오래된 페이지 부터 교체 합니다.
		- 어떻게 구현하나요?
			- 가장 오래된 페이지를 교체합니다.
		- 왜 사용 안하는가?
			- Belady의 모순
				- 프로세스에 프레임을 더 주었는데 오히려 페이지 폴트율은 더 증가하는 현상.
			- 가장 오래된 순서대로 페이지를 교체 하기 떄문에 *자주 사용 하는 페이지더라도 오래된 페이지부터 순서대로 교체하기 때문에 오히려 페이지 폴트율이 더 증가 하게 됩니다.*
	- Optimal(최적) 페이지 교체
		- *앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체하라.* 
	- LRU
		- *가장 오랜 기간 동안 사용하지 않은 페이지를 교체하는 알고리즘* 
		- 어떻게 해당 알고리즘을 구현 하나요?
			- 해당 알고리즘을 사용하려면 하드웨어적 지원이 필요하다.
				- 계수기(counters)
					- 페이지 항목마다 사용 시간 필드를 넣고 메모리가 접근될 때마다 최근 사용된 시간(Timestamp)를 저장 합니다.
					- 페이지 교체시, 가장 오래된 시간값을 가진 페이지를 교체 합니다.
				- 스택(stack)
					- 페이지 번호의 스택을 유지하는 방법이다.
					- 페이지가 참조될때마다 페이지 번호는 스택 중간에서 제거되어 스택 top에 놓이게 된다.
					- 스택 top에는 항상 가장 최근에 사용된 페이지이고, bottom은 가장 오랫동안 사용되지 않은 페이지이다.
			- LRU 페이지 교체 지원을 위한 메모리 관리 오버헤드를 감당할 수 있는 시스템이 거의 없다.
		- LRU 근사 페이지 교체 (LRU Approximation Page Replacement)
		- LRU 알고리즘을 사용하는 방법으로 페이지에 reference bit(참조 비트)를 설정하여 프로세스가 실행되면서 참조 되는 페이지의 비트를 하드웨어가 1로 세팅하여 사용 순서는 모르지만 어떤 페이지가 그동안 사용되었고 어떤 페이지가 한번도 사용되지 않았는지를 통해서 페이지 교체를 하는 방법.
		- 왜 필요한가?
			- LRU 페이지 교체 지원을 충분히 할 수 있는 하드웨어는 많지 않다.
		- 사용 알고리즘
			- 부가적 참조 비트 알고리즘 (Additional-Reference Bits Algorithm)
				- 각 페이지에 8비트인 참조 비트를 할당하여 , 페이지의 최근 사용 기록을 추적합니다.
				- 페이지가 참조될 때 하드웨어가 해당 페이지의 참조 비트의 가장 왼쪽 비트를 1로 설정 합니다.
				- 모든 페이지의 참조 비트를 비교하여 가장 작은 값을 가진 페이지를 교체 합니다.
			- 2차 기회 알고리즘 (Second-Chance Algorithm)
				- FIFO 방식에 참조 비트를 결합하여 자주 참조된 페이지에 2차 기회를 부여 합니다.
			- 개선된 2차 기회 알고리즘(Enhanced Second-Chance Algorithm)
				- 2차 기회 알고리즘을 확장하여 참조 비트와 수정 비트를 함께 사용 합니다.
- 스레싱이 뭔가요?
	- 프로세스가 실제 실행시간보다 더 많은 시간을 페이지 폴트로 인한 페이지 교체 작업에 사용하고 있는 현상을 말합니다.
- 스레싱이 왜 발생 하나요?
	- 멀티 프로그래밍 정도를 높이게 되면 많은 프로세스가 올라오게 되면서 프레임이 부족하여 페이지 폴트가 발생함.
	- 페이지 폴트를 처리하느라 CPU 이용률이 떨어지게 된다.
	- CPU가 다시 멀티 프로그래밍 정도를 올리는것을 반복 하게 된다.
- 해결 하려면 어떻게 해야 할까요?
	- *스레싱 현상을 방지하기 위해서 각 프로세스가 필요로 하는 최소한의 프레임 개수를 보장 해야한다.*
- Working-Set-Model(워킹셋)
	- 워킹셋이란?
		- 프로세스가 일정 시간 동안 참조하는 페이지들의 집합.
	- 이걸로 어떻게 해결하나?
		- 운영체제가 각 프로세스의 워킹셋을 감시하면서 각 프로세스에 작업 집합 크기에 맞는 충분한 프레임을 할당한다.


- 가상 메모리가 뭔가요?
	- 나 대답) 보조 저장 장치의 일부 영역을 메모리에 저장했던 부분에 담아서 실행할 때 메모리에 올리는 스왑 디바이스라고 합니다.
	- 스왑 디바이스를 가상 메모리라고 하나요?
		- 나 대답) 스왑디바이스 영역을 가상 메모리라고 합니다.
	- 가상 메모리가 왜 필요한가요?
		- 나 대답) 물리 메모리보다 더 큰 프로그램을 실행할 수 있게 하기 위해서 필요 합니다.
	- 가상 메모리의 관리 측면에서의 목표는 그럼 무엇인가?
		- 나 대답) 프로그램이 실행될때 실행에 필요한 부분만 메모리에 올릴 수 있게 하여서 메모리 관리를 효율적으로 하는게 목표인것 같습니다.
		- *멘토님이 수정해주신 답변)* 가상 메모리 성능이고 가상 메모리 시스템 성능은 페이지 폴트나 이런 페이지 폴트의 프리퀀시를 최소화 시키는게 기준이 됩니다.
	- 가상 메모리에서 가상 메모리 시스템 성능이 좋다 나쁘다를 어떻게 평가 할 수 있어요?
		- 나 대답) 페이지 폴트율이 낮을수록 성능이 좋다고 평가할 수 있을것 같습니다.
		- 왜요?
			- 나 대답) 페이지 폴트율이 증가하면 페이지를 보조 저장 장치에서 메모리에 가져오는 스왑핑 작업을 하게 될때 그만큼의 시스템 오버헤드를 발생 시키기 때문입니다.

- 페이지 폴트율 최소화 방법
- 하드웨어 컴포넌트 (비트벡터)
- 소프트웨어 장치들
	- 리플레이스먼트 전략
		- 알고리즘들
		- LRU
		- FIFO
			- 문제점은?
				- 프레임수를 늘렸을때 오히려 페이지 폴트율이 증가한다.
				- 왜?
					- 항상 먼저 들어온 페이지를 교체하다보니 자주 사용하는 페이지더라도 무조건 교체.
					- *멘토님 답변)* 지역성을 고려하지 않았다.
					- 페이지 폴트가 더 많은 페이지 프레임을 할당 받아도 생길 수 있다라는것을
					- 벨라디의 아노말리(Belady's Anomaly)
		- 옵티멀 알고리즘
			- 레퍼런스 스트링이라는게 옵티멀 알고리즘에 있는데 
			- 레퍼런스 스트링이란 어떤 순서대로 메모리가 참조될지 알고 있는것이다.
			- 이걸 통해서 지금 당장으로부터 가장 나중에 사용되야 하는 페이지를 교체 해준다.
	- 얼로케이션 전략
		- 고정할당 (Fixed allocation)
			- 같은 수의 정해진 수의 페이지 프레임을 각 프로세스마다 할당해 주는 전략
		- 가변할당 (Variable allocation)
			- 프로세스가 할당받을 수 있는 프레임 수가 바뀌는 전략.
	- 패치 전략
		- 디멘드 페이징
		- 프리 페이징
	- 플레이스먼트 전략
		- 어떤 세그먼트 처음 올릴 때 어디에 적재할 것인지 물어보는것.
		- 어디에 위치 하기 위해서?
			- 퍼스트 핏
				- 퍼스트 핏만의 문제점
					- 리소스 활용이 불균등 하다는 문제가 발생한다.
			- 라스트 핏
			- 베스트 핏
			- 워스트 핏
			- 넥스트 핏
				- 퍼트핏의 문제점을 해결하기 위해서 사용.
- Cleaning 전략
	- 메모리에서 변경이 발생해서 디스크로 다시 넘어올때 그냥 넘어와도 되는 경우와 디스크에도 변경점을 그냥 적용 해야 되는 경우
	- 이 변경 사항을 적용시킬 거냐에 대한 얘기
	- 2가지 방법
		- 디맨드 방식
			- 메모리에서 내려올때 라이트백이 필요하다 디스크에 수정본을 반영해야 된다면 그렇게 판단이 될때마다 사용.
		- 프리 클리닝
			- 페이지를 교체할때 드는 시간을 줄이기 위해서 미리 라이트백이 필요하다고 생각되는걸 미리 해두는것이다.
- LoadControll 전략
	- 스레싱 파트
- *allocation 전략*
	- 가변할당 (Variable allocation)
		- *프로세스에게 할당하는 프레임수가 가변적으로 할당하는 방식* 
		- 워킹셋
			- *Locality 기반으로 특정 시점에 참조되는 페이지들의 집합* 
			- 어떻게 집합을 만들 수 있나?
				- 고정된 특정시간을 두고 Locality 패턴을 분석하여 집합을 만들 수 있습니다.
				- 이때 고정된 특정시간을 Window라고 합니다.
			- process가 특정 시점에 자주 참조하는 page들의 집합
			- 시간에 따라 변함
			- Locality (지역성)
			- Window size는 고정
				- Window size vs Working Set size
					- Window size가 커짐에 따라 WS사이즈도 커지다가 어느순간에 일정하게 된다.
						- 왜?
							- Locality 때문에
		- 단점
			- Window 시간 만큼 계속 감시 해야 되서 오버헤드가 발생.
			- Page fault가 없더라도 지속적으로 관리해줘야함.
		- PFF(Page Fault Frequency algorithm)
			- page fault rate에 따라 결정하는 알고리즘. 그거에 따라 메모리에 몇개를 유지할것인가를 결정.
			- Low page fault rate
				- process에게 할당된 프레임 수를 감소
			- High page fault rate
				- process에게 할당된 프레임 수를 증가
				- 어떻게 그걸 측정 할 수 있냐?
					- page fault가 발생하고 난 후에 다음 page fault까지의 시간이 threshold value 보다 크다면 Low page fault rate
					- 시간이 작다면 High page fault rate
					- threshold value
		- VMIN (Variable MIN)
			- 평균 메모리 할당량과 page fault 발생 횟수 모두 고려 했을때의 Optimal한 알고리즘이다.

# 가상 메모리 파트 참고 링크 추가

- [성균관 대학교 운영체제론](http://www.kocw.net/home/cview.do?mty=p&kemId=696339) - 강의는 없는데 자료에는 관리법이 나온다.
