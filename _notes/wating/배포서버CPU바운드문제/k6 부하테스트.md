---
title: mokakbab-issue
permalink: /wating/k6/1
---

```
ERRO[0026] thresholds on metrics 'dropped_iterations' were crossed; at least one has abortOnFail enabled, stopping test prematurely
```

- 해당 문제는 거의 Vus 때문에 발생 할 가능성이 높다.
- [공식문서](https://grafana.com/docs/k6/latest/using-k6/scenarios/concepts/dropped-iterations/) 


# test

- Db 연동없이 그냥 nestjs hello 리턴하는 api RPS 1000이상 나옴.

```js
import { check, sleep } from "k6";
import http from "k6/http";
import { Trend } from "k6/metrics";

// 트렌드(메트릭) 정의 예시
const dataReceivedTrend = new Trend("data_received_size", true);

// k6 옵션(시나리오) 설정
// export const options = {
//     scenarios: {
//         // 1) ramp_up 시나리오
//         ramp_up: {
//             executor: "ramping-arrival-rate",
//             startRate: 100, // 초당 100 요청으로 시작
//             timeUnit: "1s",
//             preAllocatedVUs: 200, // 초기 VU 수
//             maxVUs: 1000, // 최대 VU 수
//             stages: [
//                 { target: 1000, duration: "1m" }, // 1분 동안 100 → 1000 RPS 상승
//             ],
//             gracefulStop: "0s",
//         },

//         // 2) steady_state 시나리오
//         steady_state: {
//             executor: "constant-arrival-rate",
//             rate: 1000, // 초당 1000 요청
//             timeUnit: "1s",
//             duration: "2m", // 2분 동안 유지
//             startTime: "1m", // ramp_up 시나리오 종료(1분) 후 시작
//             preAllocatedVUs: 1000,
//             maxVUs: 1500,
//         },
//     },

//     // 임계값(Thresholds)
//     thresholds: {
//         http_req_failed: [
//             { threshold: "rate<0.05", abortOnFail: true }, // 실패율 5% 미만
//         ],
//         dropped_iterations: [
//             { threshold: "rate<0.05", abortOnFail: true }, // 드롭된 시나리오 5% 미만
//         ],
//         http_req_duration: [
//             { threshold: "p(95)<3000", abortOnFail: true }, // 95퍼센타일 3초 미만
//         ],
//     },
// };

export const options = {
    scenarios: {
        simple_rps_test: {
            executor: "constant-arrival-rate",
            rate: 1000, // 초당 500개의 요청 (RPS)
            timeUnit: "1s", // RPS 단위 설정
            duration: "1m", // 테스트 지속 시간: 10초
            preAllocatedVUs: 1500, // 미리 할당할 VU 수
            maxVUs: 2000, // 최대 VU 수
        },
    },
    // 태그 추가
    tags: {
        testName: "v2-test-application",
        testType: "performance",
        component: "test",
        version: "2.0",
    },
    thresholds: {
        http_req_failed: [{ threshold: "rate<0.05", abortOnFail: true }],
        dropped_iterations: [{ threshold: "rate<0.05", abortOnFail: true }],
        http_req_duration: [{ threshold: "p(95)<3000", abortOnFail: true }],
    },
};

// 실제 테스트 함수
export default function () {
    const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";

    // Guard를 전혀 타지 않는 /test 엔드포인트 호출
    const res = http.get(`${BASE_URL}/test`, {
        timeout: "60s",
    });

    // 응답 바디 길이를 Trend 메트릭에 기록(예시)
    dataReceivedTrend.add(res.body.length);

    // 응답 코드 확인
    check(res, {
        "test status is 200": (r) => r.status === 200,
    });

    // 각 VU마다 1초 쉼 (필요 없으면 제거 가능)
    sleep(1);
}

```



# Hello

- guard 부분으로 토큰 검증만 수행.


```js
import { check, sleep } from "k6";
import http from "k6/http";
import { Trend } from "k6/metrics";

const dataReceivedTrend = new Trend("data_received_size", true);

export const options = {
    // 여러 시나리오 정의
    scenarios: {
        // 1) ramp_up 시나리오
        ramp_up: {
            executor: "ramping-arrival-rate",
            startRate: 50, // 초당 50 요청으로 시작
            timeUnit: "1s", // RPS 단위
            preAllocatedVUs: 100, // ramp-up 초기에 미리 할당할 VU 수
            maxVUs: 500, // 최대 VU 수
            stages: [
                { target: 500, duration: "1m" }, // 1분 동안 50→500 RPS 상승
            ],
            gracefulStop: "0s", // ramp_up 시나리오 끝나면 바로 종료
        },

        // 2) steady_state 시나리오
        steady_state: {
            executor: "constant-arrival-rate",
            rate: 500, // 초당 500 요청
            timeUnit: "1s",
            duration: "2m", // 2분 동안 유지
            startTime: "1m", // ramp_up 끝나는 시점(1분) 이후 시작
            preAllocatedVUs: 700,
            maxVUs: 1000,
        },
    },
};

export default function () {
    const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";
    const ACCESS_TOKEN = __ENV.ACCESS_TOKEN || "access_token";

    const helloResponse = http.get(`${BASE_URL}`, {
        headers: {
            Authorization: `Bearer ${ACCESS_TOKEN}`,
        },
        timeout: "60s",
    });

    dataReceivedTrend.add(helloResponse.body.length);

    check(helloResponse, {
        "hello status is 200": (r) => r.status === 200,
    });

    sleep(1);
}

```


- 토큰 검증하는 부분 문제라고 생각하기에는 `drop_iteration` 문제는 결국 Vus가 부족해서 생기는 문제 같기도 하다.
- `preAllocatedVUs` 를 높게 늘리니까 문제 없이 동작한다.

```js
import { check, sleep } from "k6";
import http from "k6/http";
import { Trend } from "k6/metrics";

const dataReceivedTrend = new Trend("data_received_size", true);

export const options = {
    scenarios: {
        simple_rps_test: {
            executor: "constant-arrival-rate",
            rate: 700, // 초당 500개의 요청 (RPS)
            timeUnit: "1s", // RPS 단위 설정
            duration: "1m", // 테스트 지속 시간: 10초
            preAllocatedVUs: 2000, // 미리 할당할 VU 수
            maxVUs: 3000, // 최대 VU 수
        },
    },
    // 태그 추가
    tags: {
        testName: "v2-test-application",
        testType: "performance",
        component: "test",
        version: "2.0",
    },
    thresholds: {
        http_req_failed: [{ threshold: "rate<0.05", abortOnFail: true }],
        dropped_iterations: [{ threshold: "rate<0.05", abortOnFail: true }],
        http_req_duration: [{ threshold: "p(95)<3000", abortOnFail: true }],
    },
};

export default function () {
    const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";
    const ACCESS_TOKEN = __ENV.ACCESS_TOKEN || "access_token";

    const helloResponse = http.get(`${BASE_URL}`, {
        headers: {
            Authorization: `Bearer ${ACCESS_TOKEN}`,
        },
        timeout: "60s",
    });

    dataReceivedTrend.add(helloResponse.body.length);

    check(helloResponse, {
        "hello status is 200": (r) => r.status === 200,
    });

    sleep(1);
}

```

```bash
scenarios: (100.00%) 1 scenario, 3000 max VUs, 1m30s max duration (incl. graceful stop):
              * simple_rps_test: 700.00 iterations/s for 1m0s (maxVUs: 2000-3000, gracefulStop: 30s)


     ✓ hello status is 200

     checks.........................: 100.00% 42001 out of 42001
     data_received..................: 13 MB   213 kB/s
     data_received_size.............: avg=11ms     min=11ms   med=11ms    max=11ms     p(90)=11ms     p(95)=11ms    
     data_sent......................: 14 MB   237 kB/s
   ✓ dropped_iterations.............: 0       0/s
     http_req_blocked...............: avg=535.84µs min=958ns  med=5µs     max=30.53ms  p(90)=16.33µs  p(95)=167.29µs
     http_req_connecting............: avg=523.39µs min=0s     med=0s      max=30.48ms  p(90)=0s       p(95)=0s      
   ✓ http_req_duration..............: avg=19.61ms  min=5.52ms med=11.86ms max=217.92ms p(90)=40.63ms  p(95)=77.72ms 
       { expected_response:true }...: avg=19.61ms  min=5.52ms med=11.86ms max=217.92ms p(90)=40.63ms  p(95)=77.72ms 
   ✓ http_req_failed................: 0.00%   0 out of 42001
     http_req_receiving.............: avg=64.45µs  min=7.16µs med=38.54µs max=16.51ms  p(90)=116.87µs p(95)=168.37µs
     http_req_sending...............: avg=47.22µs  min=3.16µs med=18.62µs max=40.05ms  p(90)=47.91µs  p(95)=87.29µs 
     http_req_tls_handshaking.......: avg=0s       min=0s     med=0s      max=0s       p(90)=0s       p(95)=0s      
     http_req_waiting...............: avg=19.5ms   min=5.43ms med=11.76ms max=217.88ms p(90)=40.2ms   p(95)=77.61ms 
     http_reqs......................: 42001   688.267922/s
     iteration_duration.............: avg=1.02s    min=1s     med=1.01s   max=1.21s    p(90)=1.04s    p(95)=1.08s   
     iterations.....................: 42001   688.267922/s
     vus............................: 177     min=177            max=781 
     vus_max........................: 2000    min=2000           max=2000


running (1m01.0s), 0000/2000 VUs, 42001 complete and 0 interrupted iterations
simple_rps_test ✓ [======================================] 0000/2000 VUs  1m0s  700.00 iters/s
```



# 오류 추적

## i/o timeout

- 부하 테스트 도중 `dial: i/o timeout` 오류가 다수 발생.
- `TypeORM`에서 `connectionLimit`을 300으로 설정했으나 부하 테스트 중 요청이 이를 초과하면서 큐 대기열이 발생.
- RPS 700 테스트 할려면 TypeORM에서 connectionLimit를 500으로 늘려보자.
- Innodb 버퍼풀을 3G로 늘려보자
- k6 부하테스트 스크립트를 수정
- Node.js MySQL keepAlive 딜레이 줄이기.

```
// 이전
ramp_up_test: {
            executor: "ramping-arrival-rate",
            startRate: 50, // 초당 50 요청으로 시작
            timeUnit: "1s",
            stages: [
                { target: 300, duration: "1m" }, // 1분 동안 50 → 300 RPS 증가
                { target: 700, duration: "2m" }, // 2분 동안 300 → 700 RPS 증가
            ],
            preAllocatedVUs: 1200, // VUs 증가
            maxVUs: 1600, // 최대 VUs 증가
        },
// 수정후
ramp_up_test: {
        executor: "ramping-arrival-rate",
        startRate: 50,
        timeUnit: "1s",
        stages: [
            { target: 200, duration: "2m" },
            { target: 500, duration: "3m" },
            { target: 700, duration: "5m" },
        ],
        preAllocatedVUs: 1500,
        maxVUs: 2000,
    },
```

```js
// 이전
keepAliveInitialDelay: 10000, // Keep-Alive 딜레이
enableKeepAlive: true,

// 이후
keepAliveInitialDelay: 5000,
enableKeepAlive: true,
```

```ini
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
innodb_buffer_pool_size = 2G
log_error = /var/log/mysql/error.log
log_error_verbosity = 3
max_connections = 1000
wait_timeout = 300
interactive_timeout = 300
general_log = 1
general_log_file = /var/log/mysql/general.log
performance_schema=ON
performance_schema_show_processlist = ON
```


**Threads_created의 의미**:

- MySQL은 새로운 연결 요청을 처리하기 위해 스레드를 생성합니다.
- `Threads_created` 값이 높다면, MySQL이 기존의 스레드를 재활용하지 않고 새로운 스레드를 생성하고 있다는 뜻입니다.
- 스레드 캐시(`thread_cache_size`)가 충분히 설정되어 있지 않으면, MySQL은 각 연결마다 새로운 스레드를 생성하게 됩니다.
- `Threads_created = 301` 로 문제가 있다.
- SET GLOBAL thread_cache_size = 8;로 줄임 *기존 18* 

## thread_cache_size 판단

`thread_cache_size`는 **동시 연결의 빈도와 서버 부하에 따라** 달라질 수 있습니다. 아래 기준을 사용해 적정성을 판단하세요:

1. **동시 연결 수 확인**:


```sql
SHOW STATUS LIKE 'Threads_connected';

```
    
- 현재 활성 연결 수(`Threads_connected`)가 적은 경우, `thread_cache_size`를 낮출 수 있습니다.
- 연결 수가 많으면(예: 50~100 이상), 18이 적절하거나 약간 더 늘릴 수도 있습니다.

1. **Threads_created 증가 확인**:

```sql
SHOW STATUS LIKE 'Threads_created';
```

- 이 값이 부하 테스트 중 빠르게 증가한다면, 스레드 캐시가 부족하다는 의미입니다.
- `Threads_created` 값이 느리게 증가하거나 정체된 경우, `thread_cache_size`를 낮춰도 됩니다.
3. **추천 설정**:
    - **CPU 코어 수의 2배** 또는 예상 동시 연결 수의 10~20%로 설정합니다.
    - 현재 서버는 2 vCPU이므로, **4~10 사이**가 적정 범위입니다.
    - 테스트 환경에 따라 필요 시 **12~18**로 설정해도 됩니다.


### 테스트전

### **부하 테스트 중 확인해야 할 주요 상태값**

```sql
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Threads_running';
SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Max_used_connections';
```

부하 테스트를 진행하면서, 아래 명령어를 통해 상태를 모니터링하는 것이 중요합니다:

1. **현재 연결된 스레드 수 확인**:
    
    sql
    
    코드 복사
    
    `SHOW STATUS LIKE 'Threads_connected';`
    
    - 부하 테스트 중 활성 연결 수를 실시간으로 확인합니다.
2. **활성 상태의 스레드 수 확인**:
    
    sql
    
    코드 복사
    
    `SHOW STATUS LIKE 'Threads_running';`
    
    - 실제로 실행 중인 쿼리를 처리하고 있는 스레드의 수를 보여줍니다.
    - 이 값이 지속적으로 높다면, MySQL 서버가 부하를 감당하기 어렵다는 신호일 수 있습니다.
3. **스레드 생성 빈도 확인**:
    
    sql
    
    코드 복사
    
    `SHOW STATUS LIKE 'Threads_created';`
    
    - 캐시된 스레드가 부족하여 새로 생성된 스레드의 수를 나타냅니다.
    - 부하 테스트 중 이 값이 빠르게 증가한다면, `thread_cache_size`를 늘려야 할 가능성이 있습니다.
4. **최대 사용된 연결 수 확인**:
    
    sql
    
    코드 복사
    
    `SHOW STATUS LIKE 'Max_used_connections';`
    
    - 서버가 부하 테스트 중 처리한 최대 동시 연결 수를 보여줍니다.
    - `max_connections` 설정 값을 초과하지 않는지 확인하세요.

```
mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 1     |
+-------------------+-------+
1 row in set (0.01 sec)

mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 1     |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 301   |
+-----------------+-------+
1 row in set (0.01 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 301   |
+----------------------+-------+
1 row in set (0.00 sec)

```


```sql
mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 42    |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 55    |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created'
    -> ;
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 338   |
+-----------------+-------+
1 row in set (0.01 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 301   |
+----------------------+-------+
1 row in set (0.00 sec)



```


```sql
mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 301   |
+----------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 301   |
+-------------------+-------+
1 row in set (0.01 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 584   |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 301   |
+----------------------+-------+
1 row in set (0.01 sec)
```

### 문제점
### **문제점 분석**

1. **`Threads_connected` 유지 문제**:
    
    - 테스트 종료 후에도 `Threads_connected`가 **301**로 높은 상태를 유지하고 있습니다.
    - 이는 연결이 종료되지 않고 유지되고 있음을 나타냅니다.
        - 가능성 1: 애플리케이션의 연결 풀 크기가 너무 크거나, 연결을 적절히 닫지 않음.
        - 가능성 2: MySQL의 `wait_timeout` 설정이 너무 커서 연결이 해제되지 않음.
2. **`Threads_created` 증가 문제**:
    
    - 테스트 중 `Threads_created` 값이 301 → 584로 증가.
    - 이는 `thread_cache_size`가 충분하지 않음을 의미합니다.
    - 스레드 캐싱이 적절히 이루어지지 않아 새 스레드를 생성하는 오버헤드 발생 가능.
3. **`Max_used_connections` 제한 근접**:
    - `Max_used_connections` 값이 **301**로 최대 연결 수(`max_connections`) 근처입니다.
    - 현재 설정(`max_connections=1000`)에는 여유가 있지만, 테스트 트래픽이 더 증가하면 병목 가능성이 있음.


### 해결하기
#### **1. `Threads_connected` 문제 해결**

- **애플리케이션 연결 관리 최적화**:
    
    - 애플리케이션의 데이터베이스 연결 풀 크기를 조정합니다.
    - 테스트 트래픽에 맞는 연결 풀 크기(`poolSize`) 설정이 필요합니다.
        - 예: `poolSize`를 100~200으로 설정.
    - 연결이 종료되지 않는 문제를 해결하기 위해 적절한 연결 닫기 로직을 검토하세요.
- **MySQL `wait_timeout` 조정**:
    
    - 현재 설정(`wait_timeout=300`)은 연결이 5분 동안 비활성 상태여도 해제되지 않음을 의미합니다.
    - 이를 60~120초로 줄여 비활성 연결을 신속히 해제합니다.

```sql
SET GLOBAL wait_timeout = 120;
SET GLOBAL interactive_timeout = 120;
```

#### **2. `Threads_created` 문제 해결**

- **`thread_cache_size` 최적화**:
    - 현재 설정: `thread_cache_size=18`
    - 스레드 생성 횟수를 줄이기 위해, MySQL 권장값으로 설정

```sql
SET GLOBAL thread_cache_size = 64; -- CPU 코어 수 × 8
```


#### **3. `Max_used_connections` 문제 대비**

- **`max_connections` 최적화**:
    - 현재 트래픽으로는 `max_connections=1000`이 적절하지만, 트래픽 증가를 대비해 여유를 확보하세요.
    - 예: `max_connections`를 1500~2000으로 설정.

```sql
SET GLOBAL max_connections = 1500;
```


## 부하 테스트 후 점검

```sql
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Threads_running';
SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Max_used_connections';
```


# 2번째 i/o timeout 문제 개선

- 첫번째 이후 설정을 바꿨을때보다 성능이 더 안좋음.

```ts
// 이전
extra: {
                connectionLimit: 300, // MySQL max_connections의 50%로 설정 이전에 500
                queueLimit: 1500, // 대기열 크기를 조정 이전에 2000
                waitForConnections: true,
                connectTimeout: 30000, // 연결 타임아웃
                acquireTimeout
}
// 변경점
extra: {
    connectionLimit: 500, // MySQL max_connections의 약 50%
    queueLimit: 2000, // 대기열 크기 조정
    waitForConnections: true,
    connectTimeout: 30000, // 연결 타임아웃
    acquireTimeout: 30000, // 풀에서 커넥션 획득 타임아웃
},
```

```ini
[mysqld]
max_connections = 1000
[mysqld] 
thread_cache_size = 8 //CPU 코어 * 4
[mysqld]
wait_timeout = 60
interactive_timeout = 60
```


```sql
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Threads_running';
SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Max_used_connections';
```

`thread_cache_size`의 효율성을 판단하려면, **`Threads_created`와 `Connections`의 비율**을 확인해야 합니다.

- **비율 확인**:
    - `(Threads_created / Connections) * 100` 값이 **5% 이하**라면 적절히 설정된 것입니다.
    - 이 비율이 높다면 `thread_cache_size`를 늘려야 합니다.

## 2번째 변경점

```ini
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
innodb_buffer_pool_size = 3G
innodb_buffer_pool_instances = 2
log_error = /var/log/mysql/error.log
log_error_verbosity = 3
max_connections = 1000
thread_cache_size = 8
wait_timeout = 60
interactive_timeout = 60
general_log = 1
general_log_file = /var/log/mysql/general.log
performance_schema=ON
performance_schema_show_processlist = ON
```



```sql
// 부하테스트 초기
mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 9     |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 53    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 31    |
+----------------------+-------+
1 row in set (0.00 sec)

// 문제 발생으로 종료됨
mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 31    |
+----------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 11    |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 55    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 31    |
+----------------------+-------+
1 row in set (0.00 sec)
```



#### **. MySQL 동시 처리 한계**

- `innodb_buffer_pool_size=3G`와 `thread_cache_size=8`은 적절해 보이지만, `Max_used_connections=31`로 동시 연결 수가 제한적입니다.


- TypeORM 문제

- 부하가 증가할수록 `queueLimit` 초과로 인해 `i/o timeout` 발생.


## TypeORM 커넥션 풀 최적화

```ts
extra: {
    connectionLimit: 200, // MySQL max_connections의 약 20%
    queueLimit: 500,      // 대기열 크기를 줄여 불필요한 대기 요청 방지
    waitForConnections: true,
    connectTimeout: 30000, // 연결 타임아웃
    acquireTimeout: 30000, // 풀에서 커넥션 획득 타임아웃
},
```

- 오히려 더 줄이네

#### **MySQL `wait_timeout` 및 `max_connections` 조정**

- `wait_timeout`을 늘려 비활성 연결 종료를 방지합니다:

```sql
SET GLOBAL wait_timeout = 300;
SET GLOBAL interactive_timeout = 300;
```


- `max_connections`를 늘려 동시 연결을 수용합니다:

```sql
SET GLOBAL max_connections = 500;
```


#### **네트워크 병목 확인 및 최적화**

1. **Ping 및 Latency 확인**:
    
    bash
    
    코드 복사
    
    `docker exec -it backend_prod ping mysql_prod`
    
2. **Traceroute 사용**:
    
    bash
    
    코드 복사
    
    `traceroute mysql_prod`


- 커넥션 풀이 가득 차거나 대기열 초과로 인해 `i/o timeout` 발생 가능성이 큽니다.


## Max_use_connections가 너무 작다

- `TypeORM`에서 설정한 `connectionLimit=300`이 있지만, 실제 요청이 MySQL에 도달하지 않았을 가능성이 있습니다.
- 예: `queueLimit` 초과, 연결 대기 시간이 길어 요청이 타임아웃으로 실패.


**`ulimit -n` 값이 낮음**:

- 현재 파일 디스크립터 제한이 **1024**로 설정되어 있습니다. 이는 MySQL의 동시 연결에 직접적인 제한을 줄 수 있습니다.
- 특히 높은 `max_connections=1000` 설정에도 불구하고, OS 레벨에서 이를 지원하지 못하고 있을 가능성이 큽니다.

Docker 컨테이너가 사용하는 호스트의 기본 `ulimit` 설정을 변경하려면 Docker 데몬 설정을 수정해야 합니다.

1. **Docker 데몬 설정 파일 열기** (일반적으로 `/etc/docker/daemon.json`):
    
    bash
    
    코드 복사
    
    `sudo nano /etc/docker/daemon.json`
    
2. **`default-ulimits` 추가**:
    
    json
    
    코드 복사
    
    `{   "default-ulimits": {     "nofile": {       "Name": "nofile",       "Hard": 65535,       "Soft": 65535     }   } }`




# 3번째 변경점

```bash
SHOW FULL PROCESSLIST;
```

```bash
grep "Connect" mysql/logs/general.log | wc -l
grep "Quit" mysql/logs/general.log | wc -l
grep "Aborted connection" mysql/logs/error.log | wc -l
grep "wait_timeout" mysql/logs/error.log | wc -l
```

```sql
SHOW STATUS LIKE 'Threads_connected';
SHOW STATUS LIKE 'Threads_running';
SHOW STATUS LIKE 'Threads_created';
SHOW STATUS LIKE 'Max_used_connections';
```


```
// 초기
mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 2     |
+-------------------+-------+
1 row in set (0.01 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 2     |
+----------------------+-------+
1 row in set (0.00 sec)

// k6 부하 테스트중에 i/o timeout 에러가 발생 했을때
mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 9     |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 9     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 9     |
+----------------------+-------+
1 row in set (0.00 sec)

// 부하테스트 종료
mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 9     |
+----------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_connected';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 19    |
+-------------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_running';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_running | 2     |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Threads_created';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| Threads_created | 19    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SHOW STATUS LIKE 'Max_used_connections';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Max_used_connections | 19    |
+----------------------+-------+
1 row in set (0.01 sec)

ERRO[0092] TypeError: Cannot read property 'length' of undefined
running at default (file:///scripts/participations-performance.js:56:55(87))  executor=ramping-arrival-rate scenario=ramp_up_test source=stacktrace

     ✓ participations status is 200

     checks.........................: 100.00% 8941 out of 8941
     data_received..................: 14 MB   153 kB/s
     data_received_size.............: avg=1.26s    min=576ms  med=1.25s    max=2.48s    p(90)=2.39s    p(95)=2.48s   
     data_sent......................: 3.5 MB  39 kB/s
   ✓ dropped_iterations.............: 0       0/s
     http_req_blocked...............: avg=138.28ms min=0s     med=8.4ms    max=19.77s   p(90)=13.35ms  p(95)=15.94ms 
     http_req_connecting............: avg=137.63ms min=0s     med=8.27ms   max=19.77s   p(90)=13.11ms  p(95)=15.74ms 
   ✓ http_req_duration..............: avg=13.17ms  min=0s     med=11.69ms  max=5.16s    p(90)=17.17ms  p(95)=20.66ms 
       { expected_response:true }...: avg=13.99ms  min=6.98ms med=11.88ms  max=5.16s    p(90)=17.44ms  p(95)=21.05ms 
   ✗ http_req_failed................: 5.81%   552 out of 9493
     http_req_receiving.............: avg=149.99µs min=0s     med=113.87µs max=13.72ms  p(90)=241.86µs p(95)=326.65µs
     http_req_sending...............: avg=659.76µs min=0s     med=73.62µs  max=5.15s    p(90)=188.14µs p(95)=275.89µs
     http_req_tls_handshaking.......: avg=0s       min=0s     med=0s       max=0s       p(90)=0s       p(95)=0s      
     http_req_waiting...............: avg=12.36ms  min=0s     med=11.42ms  max=123.18ms p(90)=16.73ms  p(95)=20.12ms 
     http_reqs......................: 9493    103.361591/s
     iteration_duration.............: avg=2.86s    min=1s     med=1.02s    max=30.01s   p(90)=1.04s    p(95)=30s     
     iterations.....................: 9337    101.663033/s
     vus............................: 522     min=40           max=951 
     vus_max........................: 1500    min=1500         max=1500


running (01m31.8s), 0000/1500 VUs, 9336 complete and 523 interrupted iterations
ramp_up_test ✗ [====>---------------------------------] 0365/1500 VUs  01m31.8s/10m0s  164.77 iters/s
ERRO[0092] thresholds on metrics 'http_req_failed' were crossed; at least one has abortOnFail enabled, stopping test prematurely 

mysql> SHOW FULL PROCESSLIST
    -> ;
+----+-----------------+------------------+----------+---------+------+------------------------+-----------------------+
| Id | User            | Host             | db       | Command | Time | State                  | Info                  |
+----+-----------------+------------------+----------+---------+------+------------------------+-----------------------+
|  5 | event_scheduler | localhost        | NULL     | Daemon  |  554 | Waiting on empty queue | NULL                  |
|  8 | soawn83         | 172.25.0.3:43230 | mokakbab | Sleep   |  128 |                        | NULL                  |
| 10 | soawn83         | 172.25.0.3:43248 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 11 | soawn83         | 172.25.0.3:43250 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 12 | soawn83         | 172.25.0.3:43252 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 13 | soawn83         | 172.25.0.3:43254 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 14 | soawn83         | 172.25.0.3:43256 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 15 | soawn83         | 172.25.0.3:43260 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 16 | soawn83         | 172.25.0.3:43262 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 17 | soawn83         | 172.25.0.3:43264 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 18 | soawn83         | 172.25.0.3:43266 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 19 | soawn83         | 172.25.0.3:43268 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 20 | soawn83         | 172.25.0.3:43270 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 21 | soawn83         | 172.25.0.3:43272 | mokakbab | Sleep   |  128 |                        | NULL                  |
| 22 | soawn83         | 172.25.0.3:43274 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 23 | soawn83         | 172.25.0.3:43276 | mokakbab | Sleep   |  138 |                        | NULL                  |
| 24 | soawn83         | 172.25.0.3:43278 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 25 | soawn83         | 172.25.0.3:43280 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 26 | soawn83         | 172.25.0.3:43282 | mokakbab | Sleep   |  127 |                        | NULL                  |
| 27 | root            | localhost        | NULL     | Query   |    0 | executing              | SHOW FULL PROCESSLIST |
+----+-----------------+------------------+----------+---------+------+------------------------+-----------------------+
20 rows in set (0.00 sec)

[root@mokakbab ~]# grep "Connect" mysql/logs/general.log | wc -l
36
[root@mokakbab ~]# grep "Quit" mysql/logs/general.log | wc -l
3
[root@mokakbab ~]# grep "Aborted connection" mysql/logs/error.log | wc -l
16
[root@mokakbab ~]# grep "wait_timeout" mysql/logs/error.log | wc -l
16
[root@mokakbab ~]# 


```


**Aborted connection**이 `wait_timeout`으로 인해 발생한다는 것은, **“풀에 들어가 idle 상태로 있던 커넥션이 300초를 넘겨서 MySQL이 끊었다”** 는 뜻입니다.

**i/o timeout** 에러가 자주 발생한다면, **해당 끊긴 세션을 재사용하려는 과정에서** 애플리케이션 쪽이 재연결을 제대로 못 해서 에러가 발생하는 시나리오일 수 있습니다.

**(1) wait_timeout 조정, (2) 커넥션 풀 사이즈 및 keepAlive 설정 점검, (3) 실제 에러 로그를 추적**해서, Sleep 세션이 비정상적으로 많이 쌓이진 않는지, 재연결 로직이 정상 동작하는지 등을 검증하는 것입니다.


**`Invalid configuration option: acquireTimeout`**

- 잘못된 옵션이 MySQL2 커넥션 설정에 포함되어 있습니다.


- 로그에서 `Acquiring connection`과 `Releasing connection`

```bash
Ignoring invalid configuration option passed to Connection: acquireTimeout. This is currently a warning, but in future versions of MySQL2, an error will be thrown if you pass an invalid configuration option to a Connection
```


```
SHOW VARIABLES 
WHERE Variable_name IN (
    'slow_query_log',
    'slow_query_log_file',
    'long_query_time',
    'innodb_buffer_pool_size',
    'innodb_buffer_pool_instances',
    'log_error',
    'log_error_verbosity',
    'max_connections',
    'thread_cache_size',
    'wait_timeout',
    'interactive_timeout',
    'general_log',
    'general_log_file',
    'performance_schema',
    'performance_schema_show_processlist'
);

// 로컬 설정
general_log	OFF
general_log_file	/var/lib/mysql/c45843d2a2b0.log
innodb_buffer_pool_instances	1
innodb_buffer_pool_size	134217728
interactive_timeout	28800
log_error	stderr
log_error_verbosity	2
long_query_time	10.000000
max_connections	151
performance_schema	ON
performance_schema_show_processlist	OFF
slow_query_log	OFF
slow_query_log_file	/var/lib/mysql/c45843d2a2b0-slow.log
thread_cache_size	9
wait_timeout	28800

// 배포 서버
+-------------------------------------+----------------------------+
| Variable_name                       | Value                      |
+-------------------------------------+----------------------------+
| general_log                         | ON                         |
| general_log_file                    | /var/log/mysql/general.log |
| innodb_buffer_pool_instances        | 2                          |
| innodb_buffer_pool_size             | 2147483648                 |
| interactive_timeout                 | 3600                       |
| log_error                           | /var/log/mysql/error.log   |
| log_error_verbosity                 | 3                          |
| long_query_time                     | 1.000000                   |
| max_connections                     | 1000                       |
| performance_schema                  | ON                         |
| performance_schema_show_processlist | ON                         |
| slow_query_log                      | ON                         |
| slow_query_log_file                 | /var/log/mysql/slow.log    |
| thread_cache_size                   | 8                          |
| wait_timeout                        | 3600                       |
+-------------------------------------+----------------------------+
```


```js
import { check, sleep } from "k6";
import http from "k6/http";
import { Trend } from "k6/metrics";

const dataReceivedTrend = new Trend("data_received_size", true);

export const options = {
    scenarios: {
        ramp_up_test: {
            executor: "ramping-arrival-rate",
            startRate: 50,
            timeUnit: "1s",
            stages: [
                { target: 100, duration: "2m" },
                { target: 200, duration: "3m" },
                { target: 500, duration: "5m" },
            ],
            preAllocatedVUs: 700, // 최대 target (500)보다 약간 여유 있는 수준으로 설정
            maxVUs: 1000, // 최대 target과 맞추어 설정
        },
    },
    // 태그 추가
    tags: {
        testName: "v2-participations-application",
        testType: "performance",
        component: "participations",
        version: "2.0",
    },
    thresholds: {
        http_req_failed: [{ threshold: "rate<0.05", abortOnFail: true }],
        dropped_iterations: [{ threshold: "rate<0.05", abortOnFail: true }],
        http_req_duration: [{ threshold: "p(95)<3000", abortOnFail: true }],
    },
};

export default function () {
    const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";
    const ACCESS_TOKEN = __ENV.ACCESS_TOKEN || "access_token";

    const cursors = [12001, 23000, 30000, 40000, 50000];
    const cursor = cursors[Math.floor(Math.random() * cursors.length)];
    const limit = 10;

    const articleIds = [23640, 12714, 11621, 43514];

    const participationsResponse = http.get(
        `${BASE_URL}/participations/articles/${articleIds[Math.floor(Math.random() * articleIds.length)]}?cursor=${cursor}&limit=${limit}`,
        {
            headers: {
                Authorization: `Bearer ${ACCESS_TOKEN}`,
            },
            timeout: "60s",
        },
    );

    dataReceivedTrend.add(participationsResponse.body.length);

    check(participationsResponse, {
        "participations status is 200": (r) => r.status === 200,
    });

    sleep(1);
}

```




# 커넥션 풀 그리고 반납

```log
2025-01-04T15:50:35.580521Z 705 Connect yang@192.168.65.1 on mokakbab using TCP/IP
2025-01-04T15:50:42.754542Z 706 Connect yang@192.168.65.1 on mokakbab using TCP/IP
2025-01-04T15:51:50.723706Z 705 Quit
2025-01-04T15:51:50.723713Z 706 Quit
```

- 2개를 획득 그리고 Quit Quit한다.



- read tcp 192.168.45.17:65500->27.96.130.212:80: read: connection reset by peer"
- `WARN[0017] Request Failed                                error="Get \"http://27.96.130.212/participations/articles/43514?cursor=12001&limit=10\": EOF"` 

